// CS 10
/*
1. Record structs
2. Improvements of structure types
3. Interpolated string handlers
4. global using directives
5. File-scoped namespace declaration
6. Extended property patterns
7. Improvements on lambda expressions
8. Allow const interpolated strings
9. Record types can seal ToString()
10. Improved definite assignment
11. Allow both assignment and declaration in the same deconstruction
12. Allow AsyncMethodBuilder attribute on methods
13. CallerArgumentExpression attribute
14. Enhanced #line pragma
15. Warning wave 6
*/


// 4. global using directives
/******************************************************************************/
// A global using directive must precede all non-global using directives
global using System.Text;
/******************************************************************************/


// 5. File-scoped namespace declaration
/******************************************************************************/
using CS10;

// File-scoped namespace must precede all other members in a file
// A namespace cannot directly contain members such as fields, methods or statements
// namespace CS10;
// FileScopedNamespaceDeclaration.cs
/*
// 5. File-scoped namespace declaration
namespace CS10;

class FileScopedNamespaceDeclaration { }
*/
/******************************************************************************/


/******************************************************************************/
// using System; // Unnecessary in CS 10
// using System.Collections.Generic; // Unnecessary in CS 10
// using System.Linq; // Unnecessary in CS 10
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
// using System.Threading; // Unnecessary in CS 10
// using System.Threading.Tasks; // Unnecessary in CS 10
// <ImplicitUsings>enable</ImplicitUsings> in CS10.csproj
// CS10.GlobalUsings.g.cs in obj\Debug\net6.0 or obj\Release\net6.0
/*
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
*/
/******************************************************************************/


/******************************************************************************/
// Top-level statements
// Program using top-level statements must be an executable // <OutputType>Exe</OutputType> in CS10.csproj
// class Program
// {
    // static void Main()
    // static async Task Main()
    // {
        // Version
        /******************************************************************************/
        // using System;
        Console.WriteLine($"Environment.OSVersion: {Environment.OSVersion}");
        Console.WriteLine($"Environment.OSVersion.Platform: {Environment.OSVersion.Platform}");
        Console.WriteLine($"Environment.OSVersion.Version: {Environment.OSVersion.Version}");
        Console.WriteLine($"Environment.OSVersion.VersionString: {Environment.OSVersion.VersionString}");
        Console.WriteLine($"Environment.OSVersion.Version.Major: {Environment.OSVersion.Version.Major}");
        Console.WriteLine($"Environment.OSVersion.Version.Minor: {Environment.OSVersion.Version.Minor}");
        // Empty
        // Console.WriteLine($"Environment.OSVersion.ServicePack: {Environment.OSVersion.ServicePack}");

        // Environment.Version property returns the .NET runtime version for .NET 5+ and .NET Core 3.x
        // Not recommend for .NET Framework 4.5+
        Console.WriteLine($"Environment.Version: {Environment.Version}");
        //  <-- Keep this information secure! -->
        // Console.WriteLine($"Environment.UserName: {Environment.UserName}");

        //  <-- Keep this information secure! -->
        // Console.WriteLine($"Environment.MachineName: {Environment.MachineName}");

        //  <-- Keep this information secure! -->
        // Console.WriteLine($"Environment.UserDomainName: {Environment.UserDomainName}");

        Console.WriteLine($"Environment.Is64BitOperatingSystem: {Environment.Is64BitOperatingSystem}");
        Console.WriteLine($"Environment.Is64BitProcess: {Environment.Is64BitProcess}");

        //  <-- Keep this information secure! -->
        // Console.WriteLine("CurrentDirectory: {0}", Environment.CurrentDirectory);
        //  <-- Keep this information secure! -->
        // Console.WriteLine("SystemDirectory: {0}", Environment.SystemDirectory);

        // RuntimeInformation.FrameworkDescription property gets the name of the .NET installation on which an app is running
        // .NET 5+ and .NET Core 3.x // .NET Framework 4.7.1+ // Mono 5.10.1+
        // using System.Runtime.InteropServices;
        Console.WriteLine($"RuntimeInformation.FrameworkDescription: {RuntimeInformation.FrameworkDescription}");

        Console.WriteLine($"RuntimeInformation.ProcessArchitecture: {RuntimeInformation.ProcessArchitecture}");
        Console.WriteLine($"RuntimeInformation.OSArchitecture: {RuntimeInformation.OSArchitecture}");
        Console.WriteLine($"RuntimeInformation.OSDescription): {RuntimeInformation.OSDescription}");
        // .NET Mono 6.12.0 does not contain a definition for `RuntimeIdentifier'
        Console.WriteLine($"RuntimeInformation.RuntimeIdentifier: {RuntimeInformation.RuntimeIdentifier}");

        // <-- Keep this information secure! -->
#if comments
        Console.WriteLine("Environment Variables:");
        foreach (System.Collections.DictionaryEntry de in Environment.GetEnvironmentVariables())
        {
            Console.WriteLine("{0} = {1}", de.Key, de.Value);
        }
#endif
        Console.WriteLine();
        /******************************************************************************/

        RecordClient clientRecord = new();
        clientRecord.Print();

        StructureClient clientStructure = new();
        clientStructure.Print();

        RefStructClient clientRefStruct = new();
        clientRefStruct.Print();

        GlobalUsingDirectivesClient clientGlobalUsingDirectives = new();
        clientGlobalUsingDirectives.Print();

        FileScopedNamespaceDeclarationClient clientFileScopedNamespaceDeclaration = new();
        clientFileScopedNamespaceDeclaration.Print();

        ExtendedPropertyPatterns patternsExtendedProperty = new();
        patternsExtendedProperty.Print();

        LambdaExpressions expressionsLambda = new();
        expressionsLambda.Print();

        ConstantInterpolatedStrings stringsConstantInterpolated = new();
        stringsConstantInterpolated.Print();

        RecordSealedToStringClient clientRecordSealedToString = new();
        clientRecordSealedToString.Print();

        DefiniteAssignment assignmentDefinite = new();
        assignmentDefinite.Print();

        AssignmentDeclarationInDeconstruction inDeconstructionAssignmentDeclaration = new();
        inDeconstructionAssignmentDeclaration.Print();

        AsyncMethodBuilderAttributeOnMethod onMethodAsyncMethodBuilderAttribute = new();
        onMethodAsyncMethodBuilderAttribute.Print();
        await onMethodAsyncMethodBuilderAttribute.PrintAsync();

        CallerArgumentExpressionAttributeDiagnosticsClient clientCallerArgumentExpressionAttributeDiagnostics = new();
        clientCallerArgumentExpressionAttributeDiagnostics.Print();

        EnhancedLinePragma linePragmaEnhanced = new();
        linePragmaEnhanced.Print();

        PartialMetasyntactic metasyntacticPartial = new();
        metasyntacticPartial.Print();
    // }
// }
/******************************************************************************/


// 1. Record structs
/******************************************************************************/
record struct RecordStruct
{
    public int x;
}

// readOnly record struct
readonly record struct ReadOnlyRecordStruct
{
    // Instance fields of readonly structs must be readonly
    public readonly int x = 2;
    public static int staticX = 3;

    // A 'struct' with field initializers must include an explicitly declared constructor.
    public ReadOnlyRecordStruct() { }
}

// Clarify that a record is a reference type with the record class declaration.
// Cannot be readonly
record class RecordClass
{
    public int x;
}

class RecordClient
{
    public void Print()
    {
        // 1. Record structs
        Console.WriteLine("1. Record structs");
        RecordStruct structRecord = new();
        structRecord.x = 1;
        Console.WriteLine(structRecord.x);

        // 1. Record structs: readOnly record struct
        Console.WriteLine("1. Record structs: readOnly record struct");
        ReadOnlyRecordStruct recordStructReadOnly = new();
        Console.WriteLine(recordStructReadOnly.x);
        ReadOnlyRecordStruct.staticX = 4;
        Console.WriteLine(ReadOnlyRecordStruct.staticX);

        // 1. Record: reference type"
        Console.WriteLine("1. Record: reference type");
        RecordClass classRecord = new();
        classRecord.x = 5;
        Console.WriteLine(classRecord.x);
        Console.WriteLine();
    }
}
/******************************************************************************/


// 2. Improvements of structure types
/******************************************************************************/
struct Structure
{
    public string instanceField;

    public string instanceProperty { get; set; }

    // instance parameterless constructor in a structure type 
    // initialize an instance field or property at its declaration
    public Structure()
    {
        Console.WriteLine("2. Improvements of structure types");
        Console.WriteLine("2. Improvements of structure types: instance parameterless constructor in a structure type");
        Console.WriteLine("2. Improvements of structure types: initialize an instance field or property at its declaration");
        instanceField = "initialize instance field in instance parameterless constructor in structure";
        instanceProperty = "initialize instance property in instance parameterless constructor in structure";
    }
}

record struct RecordStructure
{
    public string instanceField;
}

record class RecordReferenceType
{
    // <Nullable>enable</Nullable> in CS10.csproj // Or // The annotation for nullable reference types should only be used in code within a '#nullable' annotations context
    // Non-nullable field 'instanceField' must contain a non-null value when exiting constructor
    // Consider declaring the field as nullable
    // <Nullable>enable</Nullable> in CS10.csproj // Or // The annotation for nullable reference types should only be used in code within a '#nullable' annotations context
    public string? instanceField;
}

struct StructureClient
{
    public void Print()
    {
        Structure structureInstance = new();
        Console.WriteLine(structureInstance.instanceField);
        Console.WriteLine(structureInstance.instanceProperty);

        // Structure structureLefthandOperand = structureInstance with
        var structureLefthandOperand = structureInstance with
        {
            instanceField = "Structure instance field: A left-hand operand of the with expression can be of any structure type",
            instanceProperty = "Structure instance property",
        };

        Console.WriteLine(structureLefthandOperand.instanceField);
        Console.WriteLine(structureLefthandOperand.instanceProperty);

        RecordStructure structInstance = new();

        // RecordStructure recordStructureLefthandOperand = structInstance with
        var recordStructureLefthandOperand = structInstance with
        {
            instanceField = "A left-hand operand of the with expression can be of any structure type",
        };

        Console.WriteLine(recordStructureLefthandOperand);

        RecordReferenceType classInstance = new();

        // RecordReferenceType recordClassLefthandOperand = classInstance with
        var recordClassLefthandOperand = classInstance with
        {
            instanceField = "A left-hand operand of the with expression can be of an anonymous (reference) type",
        };

        Console.WriteLine(recordClassLefthandOperand);
        Console.WriteLine();
    }
}

public enum Signal
{
    Red,
    Amber,
    Green
}

public class Traffic
{
    public Signal SignalOn { get; init; } = Signal.Red;

    public void SignalMessage(Signal sign, string message)
    {
        if (SignalOn < sign) return;
        Console.WriteLine(message);
    }

    public void SignalMessage(Signal sign, RefStruct interpolation)
    {
        if (SignalOn < sign) return;
        Console.WriteLine(interpolation.AppendFormatted());
    }
}
/******************************************************************************/


// 3. Interpolated string handlers
/******************************************************************************/
// Interpolated string handler pattern characteristics
// System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute applied to the type
// Constructor that has two int parameters, literalLength and formatCount (More parameters are allowed)
// Public AppendLiteral method with the signature: public void AppendLiteral(string s)
// Generic public AppendFormatted method with the signature: public void AppendFormatted<T>(T t)
// using System.Runtime.CompilerServices;
[InterpolatedStringHandler]
public ref struct RefStruct
{
    StringBuilder build;

    public RefStruct(int literalLength, int formattedCount)
    {
        build = new StringBuilder(literalLength);
        Console.WriteLine($"\tliteral length: {literalLength}, formattedCount: {formattedCount}");
    }

    // AppendLiteral
    public void AppendLiteral(string s)
    {
        Console.WriteLine($"\tAppend: {{{s}}}");
        
        build.Append(s);
        Console.WriteLine($"\tAppended");
    }

    // AppendFormatted
    public void AppendFormatted<T>(T t)
    {
        Console.WriteLine($"\tFormat: {{{t}}} is of type {typeof(T)}");

        build.Append(t?.ToString());
        Console.WriteLine($"\tFormatted");
    }

    // AppendFormatted
    internal string AppendFormatted() => build.ToString();
}

struct RefStructClient
{
    public void Print()
    {
        // 3. Interpolated string handlers
        Console.WriteLine("3. Interpolated string handlers");
        var volume = new Traffic() { SignalOn = Signal.Amber };
        var time = DateTime.Now;

        volume.SignalMessage(Signal.Red, $"Stop. CurrentTime: {time}. Prohibit from proceeding");
        volume.SignalMessage(Signal.Green, $"Go. CurrentTime: {time}. Allow to proceed");
        volume.SignalMessage(Signal.Amber, "Warn. This warning is a string, not an interpolated string expression");
        Console.WriteLine();
    }
}
/******************************************************************************/


// 4. global using directives
/******************************************************************************/
// In GlobalUsingDirectives.cs file without using System.Text for StringBuilder;
/*
class GlobalUsingDirectives
{
    public string Reverse(string text)
    {
        StringBuilder build = new StringBuilder(text);
        return new string(build.ToString().Reverse().ToArray());
    }
}
*/

class GlobalUsingDirectivesClient
{
    public void Print()
    {
        Console.WriteLine("4. global using directives");
        GlobalUsingDirectives usingDirectivesGlobal = new();
        Console.WriteLine(usingDirectivesGlobal.Reverse("Reverse this string"));
        Console.WriteLine();
    }
}
/******************************************************************************/


// 5. File-scoped namespace declaration
/******************************************************************************/
class FileScopedNamespaceDeclarationClient
{
    public void Print()
    {
        Console.WriteLine("5. File-scoped namespace declaration");
        // using CS10;
        Console.WriteLine(new FileScopedNamespaceDeclaration().GetType().Namespace);
        Console.WriteLine();
    }
}

record RecordXY(int X, int Y);
record RecordAB(RecordXY A, RecordXY B);
/******************************************************************************/


// 6. Extended property patterns
/******************************************************************************/
class ExtendedPropertyPatterns
{
    // CS 9 
    // Property patterns
    bool IsNumeric(char c) => c is >= '0' and <= '9';

    // CS 9 
    // Pattern combinator and record types
    // bool IsPatternMatching(RecordAB ab) => ab is { A: { X: 0 } } or { B: { Y: 9 } };

    // CS 10
    // Reference nested properties or fields within a property pattern
    bool IsPatternMatching(RecordAB ab) => ab is { A.X: 0 } or { B.Y: 9 };

    public void Print()
    {
        Console.WriteLine("6. Extended property patterns");
        // Truthy
        Console.WriteLine(IsNumeric('1'));
        // Falsy
        Console.WriteLine(IsNumeric('A'));

        // Truthy
        RecordXY xyA = new(0, 1);
        RecordXY xyB = new(8, 9);
        RecordAB ab = new(xyA, xyB);
        Console.WriteLine(IsPatternMatching(ab));

        // Falsy
        xyA = new(9, 0);
        xyB = new(1, 2);
        ab = new(xyA, xyB);
        Console.WriteLine(IsPatternMatching(ab));
        Console.WriteLine();
    }
}

// [System.AttributeUsage(System.AttributeTargets.All)]
[System.AttributeUsage(System.AttributeTargets.Method | System.AttributeTargets.ReturnValue | System.AttributeTargets.Parameter )] 
public class AuthorAttribute : System.Attribute  
{  
    private string name;  
  
    public AuthorAttribute(string name)  
    {  
        this.name = name;  
    }  
}  

// [System.AttributeUsage(System.AttributeTargets.All)]
[System.AttributeUsage(System.AttributeTargets.Method | System.AttributeTargets.ReturnValue | System.AttributeTargets.Parameter )] 
public class VersionAttribute : System.Attribute  
{  
    public double version;  
  
    public VersionAttribute(double version)  
    {  
        this.version = version;  
    }  
}

delegate int Delegates(int i);

delegate int DelegatesRef(ref int i);

// delegate int DelegatesInteger(string s);
/******************************************************************************/


// 7. Improvements on lambda expressions
/******************************************************************************/
class LambdaExpressions
{
    // CS 10
    // Attributes can be applied to lambda expressions
    // The attributes are added before the parameter declaration
    // The lambda expression's parameter list must be parenthesized when there are attributes
    // Multiple attributes may be specified, either comma-separated within the same attribute list or as separate attribute lists    
    Func<int, int> f1 = [Author("Rajani")][Version(1.1)] (int x) => x * x;

    Func<int, int> f2 = [Author("Rajani"), Version(1.1)] (int x) => x * x;

    Func<int, int> f3 = [return: Author("Rajani")] (x) => x * x;

    Func<int, int> f4 = [Author("Rajani")] static (x) => x * x;

    Func<int, int> f5 = ([Author("Rajani")] x) => x * x;

    Delegates f6 = [Author("Rajani")] (int x) => x * x;

    DelegatesRef f7 = ([Author("Rajani")] ref int x) => x * x;

    // Attributes are not supported for anonymous methods declared with delegate { }
    // Delegates f8 = [Author("Rajani")] delegate { return 8; };
    Delegates f8 = delegate { return 8; };

    public void Print()
    {
        Console.WriteLine("7. Improvements on lambda expressions: Natural type for lambda expressions");
        // Lambda expressions may have a natural type, where the compiler can infer a delegate type from the lambda expression or method group
        // Lambda expressions may declare a return type when the compiler can't infer it
        var naturalType = (string text) => Convert.ToInt32(text);
        // Compiler can infer left-hand operand to be a Func<string, int>
        // Compiler will use an available Func or Action delegate, if a suitable one exists
        // Otherwise, it will synthesize a delegate type
        // The type must be synthesized if the lambda expression has ref parameters
        // When a lambda expression has a natural type, it can be assigned to a less explicit type, such as System.Object, or System.Delegate
        // object naturalType  = (string text) => Convert.ToInt32(text); // Func<string, int> 
        // Delegate naturalType = (string text) => Convert.ToInt32(text); // Func<string, int>
        Console.WriteLine(naturalType("123"));

        // Method groups (that is, method names without argument lists) with exactly one overload have a natural type
        var read = Console.Read; // Func<int> inferred

        var readLine = Console.ReadLine; // Func<int> inferred
        Console.WriteLine("Enter input");
        Console.WriteLine($"Input = {readLine()}");

        // The delegate type could not be inferred
        // var write = Console.Write;

        // If you assign a lambda expression to System.Linq.Expressions.LambdaExpression, or System.Linq.Expressions.Expression
        // and the lambda has a natural delegate type, the expression has a natural type of System.Linq.Expressions.Expression<TDelegate>
        // with the natural delegate type used as the argument for the type parameter
        LambdaExpression naturalDelegateTypeLambdaExpression = (string text) => Convert.ToInt32(text); // Expression<Func<string, int>>
        Expression naturalDelegateTypeExpression = (string text) => Convert.ToInt32(text); // Expression<Func<string, int>>	
        Console.WriteLine(naturalDelegateTypeLambdaExpression.Compile().DynamicInvoke("456"));
        Console.WriteLine(naturalDelegateTypeLambdaExpression.Compile().DynamicInvoke("789"));
        // Many lambda expressions won't have a natural type
        // Consider the following declaration
        // var toInt32 = text => Convert.ToInt32(text); // ERROR: Not enough type info in the lambda // error CS8917: The delegate type could not be inferred
        // The compiler can't infer a parameter type for text. When the compiler can't infer a natural type, you must declare the type
        Func<string, int> toInt32 = text => Convert.ToInt32(text);

        Console.WriteLine("7. Improvements on lambda expressions: Declared return type");
        // Lambda expressions may declare a return type when the compiler can't infer it
        // The return type of the lambda expression is obvious and inferred, for some expressions, that wouldn't work
        // var declaredReturnType = (string? text) => string.IsNullOrWhiteSpace(text) ? 0 : "Not Null Or WhiteSpace"; // ERROR: Can't infer return type
        // C10 allows to specify the return type on a lambda expression before the parameters
        // When you specify an explicit return type, the parameters must be parenthesized
        // <Nullable>enable</Nullable> in CS10.csproj // Or // The annotation for nullable reference types should only be used in code within a '#nullable' annotations context
        var declaredReturnType = object (string? text) => string.IsNullOrWhiteSpace(text) ? 0 : "Not Null Or WhiteSpace";
        Console.WriteLine(declaredReturnType(null));

        Console.WriteLine("7. Improvements on lambda expressions: Attributes");
        // Attributes can be applied to lambda expressions
        Console.WriteLine(f1(1));
        Console.WriteLine(f2(2));
        Console.WriteLine(f3(3));
        Console.WriteLine(f4(4));
        Console.WriteLine(f5(5));
        Console.WriteLine(f6(6));
        int i = 7;
        Console.WriteLine(f7(ref i));
        Console.WriteLine(f8(7));
        Console.WriteLine();
    }
}
/******************************************************************************/


// 8. Allow const interpolated strings
/******************************************************************************/
class ConstantInterpolatedStrings
{
    // The placeholder expressions can't be numeric constants because those constants are converted to strings at run time
    // const strings may be initialized using string interpolation if all the placeholders are themselves constant strings
    // The expression being assigned to must be constant string
    //  Every interpolation expression must be a string, and it must be a compile time constant
    const string text = "The expression being assigned to must be constant";
    const string memberText = $"{text}";
    
    const string textAppend = "string";
    const string memberTextAppend = $"{memberText} {textAppend}";

    // Note
    // The type 'DateTime' cannot be declared const
    // const DateTime timeDate = default(DateTime);
    // A const field of a reference type other than string can only be initialized with null
    // The string cannot be null
    const string initializedWithNull = null;
    const string defaultOfString = default(string);

    // The string can be ""
    const string EmptyStrings = "";

    // const string cannot initialized with string.Empty
    // const string stringEmpty = string.Empty;

    // CS 10 // Note
    // The current culture may affect their string representation
    // When an interpolated string is used, the compiler checks if the interpolated string is assigned to a type that satisfies the interpolated string handler pattern
    // Interpolated string handler is a custom type that converts the interpolated string into a string

    public void Print()
    {
        Console.WriteLine("8. Allow const interpolated strings");
        Console.WriteLine(memberText);
        Console.WriteLine(textAppend);
        Console.WriteLine(memberTextAppend);

        const string localText = $"The expression being assigned to must not only be constant but also {textAppend}";
        Console.WriteLine(localText);

        Console.WriteLine(initializedWithNull);
        Console.WriteLine(string.IsNullOrWhiteSpace(initializedWithNull));
        Console.WriteLine(initializedWithNull == null);

	    // The expression being assigned cannot be null
        // const string localTextAppend = $"{localText} and the string cannot be null + {initializedWithNull}";

        Console.WriteLine(defaultOfString);
        Console.WriteLine(string.IsNullOrWhiteSpace(defaultOfString));
        Console.WriteLine(defaultOfString == null);

        // The expression being assigned cannot be default(string)
        // const string localTextAppend = $"{localText} and the string cannot be null + {defaultOfString}";

        Console.WriteLine(EmptyStrings);
        Console.WriteLine(string.IsNullOrWhiteSpace(EmptyStrings));
        Console.WriteLine(EmptyStrings == null);

        const string localTextAppend = $"{localText} and the string cannot be null, can be empty strings:{EmptyStrings}";
        Console.WriteLine(localTextAppend);
        Console.WriteLine();
    }
}
/******************************************************************************/


// 9. Record types can seal ToString()
/******************************************************************************/
record RecordSealedToString
{
    public int X;
    public int Y;

    // CS 10 // The compiler will synthesize PrintMembers when a base record has sealed the ToString method     
    // Also create custom implementation of PrintMembers
    // Custom implementation of ToString may include the sealed modifier, which prevents the compiler from synthesizing a ToString implementation for any derived records
    // Effectively, that means the ToString output won't include the runtime type information
    // All members and values are displayed, because derived records will still have a PrintMembers method generated
    public sealed override string ToString()
    {
        // return $"{this.GetType().Name} {{ X = {X}, Y = {Y} }}";
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.Append(this.GetType().Name); // Type Name
        stringBuilder.Append(" { ");
        if (PrintMembers(stringBuilder))
        {
            stringBuilder.Append(" ");
        }
        stringBuilder.Append("}");
        return stringBuilder.ToString();
    }
}

class RecordSealedToStringClient
{
    public void Print()
    {
        Console.WriteLine("9. Record types can seal ToString()");
        RecordSealedToString sealedToStringRecord = new();
        sealedToStringRecord.X = 1;
        sealedToStringRecord.Y = 2;

        string sealedToString = sealedToStringRecord.ToString();
        Console.WriteLine(sealedToString);
        Console.WriteLine();
    }
}

class Assignment
{
    public bool GetValueOut(out object objectOut)
    {
        // objectOut = Activator.CreateInstance(typeof(object));
        objectOut = new object();
        if (objectOut == null)
        {
            return false;
        }
        return true;
    }
}
/******************************************************************************/


// 10. Improved definite assignment
/******************************************************************************/
class DefiniteAssignment
{
    Assignment instance = new();
    // warning CS8601: Possible null reference assignment
    // string text = string.Empty;
    // <Nullable>enable</Nullable> in CS10.csproj // Or // The annotation for nullable reference types should only be used in code within a '#nullable' annotations context
    string? text = string.Empty;

    public void NullCheck()
    {
        if ((instance != null && instance.GetValueOut(out object objectOut)) == true)
        {
            text = objectOut.ToString();
        }
    }

    public void NullConditional()
    {
        // using ?.
        if (instance?.GetValueOut(out object objectOut) == true)
        {
            text = objectOut.ToString();
        }
    }

    public void NullCoalescing()
    {
        // using ??
        if (instance?.GetValueOut(out object objectOut) ?? false)
        {
            text = objectOut.ToString();
        }
    }

    public void Print()
    {
        Console.WriteLine("10. Improved definite assignment");
        NullCheck();
        NullConditional();
        NullCoalescing();
        Console.WriteLine();
    }
}

record RecordConstruction(int X, int Y);
/******************************************************************************/


// 11. Allow both assignment and declaration in the same deconstruction
/******************************************************************************/
class AssignmentDeclarationInDeconstruction
{
    public void Print()
    {
        Console.WriteLine("11. Allow both assignment and declaration in the same deconstruction");
        RecordConstruction constructionRecord = new RecordConstruction(1, 2);

        // Pre-CS 10 // Deconstruction could assign all values to existing variables, or initialize newly declared variables:
        // Initialization (newly declared variables):
        (int a, int b) = constructionRecord;
        Console.WriteLine($"a = {a}, b = {b}");
        // Assignment (existing variables):
        int c = 0;
        int d = 0;
        // Deconstruction
        (c, d) = constructionRecord;
        Console.WriteLine($"c = {c}, d = {d}");

        // CS 10 // existing variables and newly declared variables
        int e = 0;
        // Deconstruction
        (e, int f) = constructionRecord;
        Console.WriteLine($"e = {e}, f = {f}");
        Console.WriteLine();
    }
}

class CustomTaskBuilder
{
    public static CustomTaskBuilder Create() => new();
    public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine { }
    public void SetStateMachine(IAsyncStateMachine stateMachine) { }
    public void SetResult() { }
    public void SetException(Exception exception) { }
    // public Task Task => default(Task);
    public Task Task => Task.Run(() => Thread.Sleep(1000));

    public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)
        where TAwaiter : System.Runtime.CompilerServices.INotifyCompletion
        where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine
    { }

    public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)
        where TAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion
        where TStateMachine : System.Runtime.CompilerServices.IAsyncStateMachine
    { }
}
/******************************************************************************/


// 12. Allow AsyncMethodBuilder attribute on methods
/******************************************************************************/
class AsyncMethodBuilderAttributeOnMethod
{
    // using System.Runtime.CompilerServices;
    [AsyncMethodBuilder(typeof(CustomTaskBuilder))]
    public void Print()
    {
        Console.WriteLine("12. Allow AsyncMethodBuilder attribute on methods");
    }

    public async Task PrintAsync()
    {
        Task taskAsync = Task.Run(() => Thread.Sleep(1000)); // Task taskAsync = Task.Run(() => Task.Delay(1000));
        Console.WriteLine(taskAsync.GetType());
        Console.WriteLine();
        await taskAsync;
    }
}
/******************************************************************************/


// 13. CallerArgumentExpression attribute
/******************************************************************************/
class CallerArgumentExpressionAttributeDiagnostics
{
    // System.Runtime.CompilerServices.CallerArgumentExpressionAttribute specifies a parameter that the compiler replaces with the text representation of another argument
    // This feature enables libraries to create more specific diagnostics
    // Tests a condition
    // If the condition is false, the exception message contains the text representation of the argument passed to condition
    // using System.Runtime.CompilerServices;   
    // <Nullable>enable</Nullable> in CS10.csproj // Or // The annotation for nullable reference types should only be used in code within a '#nullable' annotations context 
    public static void Verify(string name, bool flag, [CallerArgumentExpression("flag")] string? text = null) // Utility method hence static
    {
        if (!flag)
        {
            throw new ArgumentException($"Argument failed validation: <{text}>", name);
        }
    }
}

static class Extension
{
    // <Nullable>enable</Nullable> in CS10.csproj // Or // The annotation for nullable reference types should only be used in code within a '#nullable' annotations context
    public static IEnumerable<T> Set<T>(this IEnumerable<T> enumerable, int occurrence, [CallerArgumentExpression("enumerable")] string? text = null)
    {
        if (enumerable.Count() < occurrence)
        {
            throw new ArgumentException($"Expression doesn't have enough elements: {text}", nameof(enumerable));
        }

        int counter = 0;

        foreach (T enumerate in enumerable)
        {
            if (counter++ % occurrence == 0)
            {
                yield return enumerate;
            }
        }
    }
}

class ConsoleWriteLiner
{
    // <Nullable>enable</Nullable> in CS10.csproj // Or // The annotation for nullable reference types should only be used in code within a '#nullable' annotations context
    public string? consoleText;

    public void ConsoleWriteLine()
    {
        Console.WriteLine(consoleText);
    }
}

class ActionWriteLiner
{
    // <Nullable>enable</Nullable> in CS10.csproj // Or // The annotation for nullable reference types should only be used in code within a '#nullable' annotations context
    public string? actionText;

    public Action ActionConsoleWriteLine()
    {
        Console.WriteLine(actionText);
        return Console.WriteLine;
    }
}

class Beeper
{
    public void ConsoleBeeper()
    {
        Console.Beep();
    }

    public Action ActionBeeper()
    {
        return Console.Beep;
    }
}

class CallerArgumentExpressionAttributeDiagnosticsClient
{
    public void Invoker(Action act)
    {
        // CallerArgumentExpressionAttributeDiagnostics.Verify(nameof(act), act is not null, "This argument is passed to condition from Invoke");
        CallerArgumentExpressionAttributeDiagnostics.Verify(nameof(act), act is null, "This argument is passed to condition from Invoke");
        // act();
        // act.Invoke();
        // act.DynamicInvoke();
    }

    public void Print()
    {
        Console.WriteLine("13. CallerArgumentExpression attribute");
        ConsoleWriteLiner writeLinerConsole = new ConsoleWriteLiner();
        writeLinerConsole.consoleText = "Console Text";
        // Delegate `System.Action' does not take arguments
        Action actConsoleWriteLiner = writeLinerConsole.ConsoleWriteLine;
        try
        {
            Invoker(actConsoleWriteLiner);
        }
        catch (ArgumentException ex)
        {
            Console.WriteLine(ex.ToString());
        }

        ActionWriteLiner writeLinerAction = new ActionWriteLiner();
        writeLinerAction.actionText = "Action Text";
        // Delegate `System.Action' does not take arguments
        Action actActionWriteLiner = () => writeLinerAction.ActionConsoleWriteLine();
        try
        {
            Invoker(actActionWriteLiner);
        }
        catch (ArgumentException ex)
        {
            Console.WriteLine(ex.ToString());
        }

        Beeper consoleBeep = new Beeper();
        // Delegate `System.Action' does not take arguments
        Action actConsoleBeep = consoleBeep.ConsoleBeeper;
        try
        {
            Invoker(actConsoleBeep);
        }
        catch (ArgumentException ex)
        {
            Console.WriteLine(ex.ToString());
        }

        Beeper actionBeep = new Beeper();
        // Delegate `System.Action' does not take arguments
        // Action actActionBeep = () => actionBeep.ActionBeeper();
        Action actActionBeep = actionBeep.ActionBeeper();
        try
        {
            Invoker(actActionBeep);
        }
        catch (ArgumentException ex)
        {
            Console.WriteLine(ex.ToString());
        }

        // IEnumerable<int> enumerable = Enumerable.Range(0, 10).Set(10, "This argument is passed to condition from Set");
        // counter++
        IEnumerable<int> enumerable = Enumerable.Range(0, 10).Set(11, "This argument is passed to condition from Set");

        try
        {
            enumerable.ToList().ForEach(x => Console.WriteLine(x));
        }
        catch (ArgumentException aex)
        {
            Console.WriteLine(aex.ToString());
        }
        Console.WriteLine();
    }
}
/******************************************************************************/


// 14. Enhanced #line pragma
/******************************************************************************/
class EnhancedLinePragma
{
    public void Print()
    {
        Console.WriteLine("14. Enhanced #line pragma");
        // CS 10 // New form of the #line directive
#line (1, 1) - (5, 60) 10 "partial-class.g.cs"
        /*34567*/
        int b = 0;
        // The components of this form are
        // (1, 1): The start line and column for the first character on the line that follows the directive
        // The next line would be reported as line 1, column 1
        // (5, 60): The end line and column for the marked region
        // 10: The column offset for the #line directive to take effect
        // The 10th column would be reported as column one
        // That's where the declaration int b = 0; begins
        // This field is optional
        // If omitted, the directive takes effect on the first column
        // "partial-class.g.cs": The name of the output file
        // Generates the following warning
        // partial-class.g.cs(1,5,1,6): warning CS0219: The variable 'b' is assigned but its value is never used
        // After remapping, the variable, b, is on the first line, at character six
        // Domain-specific languages (DSLs) typically use this format to provide a better mapping from the source file to the generated C# output
        Console.WriteLine();
    }
}
/******************************************************************************/


// 15. Warning wave 6
/******************************************************************************/
public partial class PartialMetasyntactic
{
    public void Print()
    {
        Console.WriteLine("15. Warning wave 6");
    }

    public partial void Foo(int x);

    public partial T Bar<T>(string s) where T : struct;

    public partial void Baz(string s);

    public partial void Qux(object o);

    public partial void Quux(dynamic o);

    public partial void Corge(string? s);
}

public partial class PartialMetasyntactic
{
    // Different parameter names:
    public partial void Foo(int y) { }

    // Different type parameter names:
    public partial TResult Bar<TResult>(string s) where TResult : struct => default;

    // Relaxed nullability
    public partial void Baz(string? s) { }

    // Mixing object and dynamic
    public partial void Qux(dynamic o) { }

    // Mixing object and dynamic
    public partial void Quux(object o) { }

    // Note: This generates CS8611 (nullability mismatch) not CS8826
    public partial void Corge(string s) { } 
}
/******************************************************************************/


// Output
/*
Environment.OSVersion: Unix 14.4.1
Environment.OSVersion.Platform: Unix
Environment.OSVersion.Version: 14.4.1
Environment.OSVersion.VersionString: Unix 14.4.1
Environment.OSVersion.Version.Major: 14
Environment.OSVersion.Version.Minor: 4
Environment.Version: 6.0.26
Environment.Is64BitOperatingSystem: True
Environment.Is64BitProcess: True
RuntimeInformation.FrameworkDescription: .NET 6.0.26
RuntimeInformation.ProcessArchitecture: Arm64
RuntimeInformation.OSArchitecture: Arm64
RuntimeInformation.OSDescription): Darwin 23.4.0 Darwin Kernel Version 23.4.0: Fri Mar 15 00:10:42 PDT 2024; root:xnu-10063.101.17~1/RELEASE_ARM64_T6000
RuntimeInformation.RuntimeIdentifier: osx.14-arm64

1. Record structs
1
1. Record structs: readOnly record struct
2
4
1. Record: reference type
5

2. Improvements of structure types
2. Improvements of structure types: instance parameterless constructor in a structure type
2. Improvements of structure types: initialize an instance field or property at its declaration
initialize instance field in instance parameterless constructor in structure
initialize instance property in instance parameterless constructor in structure
Structure instance field: A left-hand operand of the with expression can be of any structure type
Structure instance property
RecordStructure { instanceField = A left-hand operand of the with expression can be of any structure type }
RecordReferenceType { instanceField = A left-hand operand of the with expression can be of an anonymous (reference) type }

3. Interpolated string handlers
        literal length: 45, formattedCount: 1
        Append: {Stop. CurrentTime: }
        Appended
        Format: {5/26/2024 9:18:24PM} is of type System.DateTime
        Formatted
        Append: {. Prohibit from proceeding}
        Appended
Stop. CurrentTime: 5/26/2024 9:18:24PM. Prohibit from proceeding
        literal length: 35, formattedCount: 1
        Append: {Go. CurrentTime: }
        Appended
        Format: {5/26/2024 9:18:24PM} is of type System.DateTime
        Formatted
        Append: {. Allow to proceed}
        Appended
Warn. This warning is a string, not an interpolated string expression

4. global using directives
gnirts siht esreveR

5. File-scoped namespace declaration
CS10

6. Extended property patterns
True
False
True
False

7. Improvements on lambda expressions: Natural type for lambda expressions
123
Enter input
5
Input = 5
456
789
7. Improvements on lambda expressions: Declared return type
0
7. Improvements on lambda expressions: Attributes
1
4
9
16
25
36
49
8

8. Allow const interpolated strings
The expression being assigned to must be constant
string
The expression being assigned to must be constant string
The expression being assigned to must not only be constant but also string

True
True

True
True

True
False
The expression being assigned to must not only be constant but also string and the string cannot be null, can be empty strings:

9. Record types can seal ToString()
RecordSealedToString { X = 1, Y = 2 }

10. Improved definite assignment

11. Allow both assignment and declaration in the same deconstruction
a = 1, b = 2
c = 1, d = 2
e = 1, f = 2

12. Allow AsyncMethodBuilder attribute on methods
System.Threading.Tasks.Task

13. CallerArgumentExpression attribute
System.ArgumentException: Argument failed validation: <This argument is passed to condition from Invoke> (Parameter 'act')
   at CallerArgumentExpressionAttributeDiagnostics.Verify(String name, Boolean flag, String text) in /Users/rajaniapple/Desktop/GitHub/CS/CS/CS/CS10/macOSarm64/CS10/Program.cs:line 867
   at CallerArgumentExpressionAttributeDiagnosticsClient.Invoker(Action act) in /Users/rajaniapple/Desktop/GitHub/CS/CS/CS/CS10/macOSarm64/CS10/Program.cs:line 935
   at CallerArgumentExpressionAttributeDiagnosticsClient.Print() in /Users/rajaniapple/Desktop/GitHub/CS/CS/CS/CS10/macOSarm64/CS10/Program.cs:line 950
System.ArgumentException: Argument failed validation: <This argument is passed to condition from Invoke> (Parameter 'act')
   at CallerArgumentExpressionAttributeDiagnostics.Verify(String name, Boolean flag, String text) in /Users/rajaniapple/Desktop/GitHub/CS/CS/CS/CS10/macOSarm64/CS10/Program.cs:line 867
   at CallerArgumentExpressionAttributeDiagnosticsClient.Invoker(Action act) in /Users/rajaniapple/Desktop/GitHub/CS/CS/CS/CS10/macOSarm64/CS10/Program.cs:line 935
   at CallerArgumentExpressionAttributeDiagnosticsClient.Print() in /Users/rajaniapple/Desktop/GitHub/CS/CS/CS/CS10/macOSarm64/CS10/Program.cs:line 963
System.ArgumentException: Argument failed validation: <This argument is passed to condition from Invoke> (Parameter 'act')
   at CallerArgumentExpressionAttributeDiagnostics.Verify(String name, Boolean flag, String text) in /Users/rajaniapple/Desktop/GitHub/CS/CS/CS/CS10/macOSarm64/CS10/Program.cs:line 867
   at CallerArgumentExpressionAttributeDiagnosticsClient.Invoker(Action act) in /Users/rajaniapple/Desktop/GitHub/CS/CS/CS/CS10/macOSarm64/CS10/Program.cs:line 935
   at CallerArgumentExpressionAttributeDiagnosticsClient.Print() in /Users/rajaniapple/Desktop/GitHub/CS/CS/CS/CS10/macOSarm64/CS10/Program.cs:line 975
System.ArgumentException: Argument failed validation: <This argument is passed to condition from Invoke> (Parameter 'act')
   at CallerArgumentExpressionAttributeDiagnostics.Verify(String name, Boolean flag, String text) in /Users/rajaniapple/Desktop/GitHub/CS/CS/CS/CS10/macOSarm64/CS10/Program.cs:line 867
   at CallerArgumentExpressionAttributeDiagnosticsClient.Invoker(Action act) in /Users/rajaniapple/Desktop/GitHub/CS/CS/CS/CS10/macOSarm64/CS10/Program.cs:line 935
   at CallerArgumentExpressionAttributeDiagnosticsClient.Print() in /Users/rajaniapple/Desktop/GitHub/CS/CS/CS/CS10/macOSarm64/CS10/Program.cs:line 988
System.ArgumentException: Expression doesn't have enough elements: This argument is passed to condition from Set (Parameter 'enumerable')
   at Extension.Set[T](IEnumerable`1 enumerable, Int32 occurrence, String text)+MoveNext() in /Users/rajaniapple/Desktop/GitHub/CS/CS/CS/CS10/macOSarm64/CS10/Program.cs:line 879
   at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)
   at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)
   at CallerArgumentExpressionAttributeDiagnosticsClient.Print() in /Users/rajaniapple/Desktop/GitHub/CS/CS/CS/CS10/macOSarm64/CS10/Program.cs:line 1001

14. Enhanced #line pragma

15. Warning wave 6
*/


// Credit:
/*
https://dotnet.microsoft.com/
*/