// Mnemonics / CS // Java // Subject to updates in newer versions of CS and Java

/******************************************************************************/
// CS // class, interface, struct, readonly struct, ref struct, readonly ref struct, record, positional record, record struct, readonly record struct
/******************************************************************************/
/*
// Reference Type 
class C : I
{
    static C() { }
    public C() { }
    ~C() { }
}

// Reference Type 
interface I
{
    static I() { }
}

// Value Type
// struct can implement interface only
struct S : I
{
    static S() { }
    public S() { }
}

// CS 7.2 // Value Type
readonly struct ReadOnlyStructure : I
{
    static ReadOnlyStructure() { }
    public ReadOnlyStructure() { }
}
// ref structs cannot implement interface 
ref struct RefStructure
{
    static RefStructure() { }
    public RefStructure() { }
}
readonly ref struct ReadOnlyRefStructure
{
    static ReadOnlyRefStructure() { }
    public ReadOnlyRefStructure() { }
}

// CS 9 // Reference Type 
// Can inherit object or another record only and implement interface
// Cannot inherit class and cannot be base for class
record BaseRecord : I
{
    static BaseRecord() { }
    public BaseRecord() { }
    ~BaseRecord() { }
}
record DerivedRecord : BaseRecord, I
{
    static DerivedRecord() { }
    public DerivedRecord() { }
    ~DerivedRecord() { }
}
record ObjectRecord : object, I
{
    static ObjectRecord() { }
    public ObjectRecord() { }
    ~ObjectRecord() { }
}
// Positional records
// The primary constructor parameters to a record are referred to as positional parameters.
record BasePositionalRecord(string Alpha, string Beta) : I
{
    static BasePositionalRecord() { }
    public BasePositionalRecord() : this(string.Empty, string.Empty) { }
    ~BasePositionalRecord() { }
}
record DerivedPositionalRecord(string Alpha, string Beta, string Gamma) : BasePositionalRecord(Alpha, Beta), I
{
    static DerivedPositionalRecord() { }
    public DerivedPositionalRecord() : this(string.Empty, string.Empty, string.Empty) { }
    ~DerivedPositionalRecord() { }
}
record ObjectPositionalRecord(string Epsilon, string Zeta) : object, I
{
    static ObjectPositionalRecord() { }
    public ObjectPositionalRecord() : this(string.Empty, string.Empty) { }
    ~ObjectPositionalRecord() { }
}
// Positional record extending record
record ExtendedPositionalRecord(string Alpha, string Beta, string Gamma) : BaseRecord, I
{
    static ExtendedPositionalRecord() { }
    public ExtendedPositionalRecord() : this(string.Empty, string.Empty, string.Empty) { }
    ~ExtendedPositionalRecord() { }
}
// Record extending positional record 
record ExtentedRecord : BasePositionalRecord, I
{
    static ExtentedRecord() { }
    public ExtentedRecord() : this(string.Empty, string.Empty, string.Empty) { }
    public ExtentedRecord(string Alpha, string Beta, string Gamma) : base(Alpha, Beta) { }
    ~ExtentedRecord() { }
}

// CS 10 // Value Type
record struct RecordStructure : I
{
    static RecordStructure() { }
    public RecordStructure() { }
}
readonly record struct ReadOnlyRecordStructure : I
{
    static ReadOnlyRecordStructure() { }
    public ReadOnlyRecordStructure() { }
}
*/
/******************************************************************************/


/******************************************************************************/
// CS // Nested Types
/******************************************************************************/
/*
class OuterClass 
{
    class InnerClass 
    {
             public void innerClassMethod() 
             {
                System.Console.WriteLine("Inner class method");
              }
     }
    public void outerClassMethod()
    {
        System.Console.WriteLine("Outer class method");
        InnerClass classInner = new InnerClass();
        classInner.innerClassMethod();
     }
}

class Program
{
    static void Main() 
    {
        OuterClass classOuter = new OuterClass();
        classOuter.outerClassMethod();
     }
}
*/
/******************************************************************************/


/******************************************************************************/
// Java // class, interface, record, enum, sealed, non-sealed, final, permitted subclasses, primitive, public, static
/******************************************************************************/
/*
public class Program {
    public static void main(String args[]) {
       Program pro = new Program();
       pro.print();
    }
    
    public void print() {
        Class cls = null;

        // cls = C.class;
        /*
        isPublic: false
        isStatic: false // false if nested without static modifier 
        isFinal: false
        isSealed: false
        isPrimitive: false
        getPermittedSubclasses: null
        */
        
        // cls = SC.class;
        /*
        isPublic: false
        isStatic: false // false if nested without static modifier 
        isFinal: false
        isSealed: true
        isPrimitive: false
        getPermittedSubclasses: [class NSC]
        */

        // cls = NSC.class;
        /*
        isPublic: false
        isStatic: false // false if nested without static modifier 
        isFinal: false
        isSealed: false
        isPrimitive: false
        getPermittedSubclasses: null
        */
        
        // cls = FC.class;
        /*
        isPublic: false
        isStatic: false // false if nested without static modifier 
        isFinal: true
        isSealed: false
        isPrimitive: false
        getPermittedSubclasses: null
        */

        // cls = I.class;
        /*
        isPublic: false
        isStatic: false // true if nested even without static modifier 
        isFinal: false // interface cannot be final
        isSealed: false
        isPrimitive: false
        getPermittedSubclasses: null
        */
        
        // cls = SI.class;
        /*
        isPublic: false
        isStatic: false // true if nested even without static modifier 
        isFinal: false // interface cannot be final
        isSealed: true
        isPrimitive: false
        getPermittedSubclasses: [interface NSI, class FC]
        */
        
        // cls = NSI.class;
        /*
        isPublic: false
        isStatic: false // true if nested even without static modifier 
        isFinal: false // interface cannot be final
        isSealed: false
        isPrimitive: false
        getPermittedSubclasses: null
        */
        
        // cls = R.class;
        /*
        isPublic: false
        isStatic: false // true if nested even without static modifier 
        isFinal: true
        isSealed: false
        isPrimitive: false
        getPermittedSubclasses: null
        */

        // cls = FR.class;
        /*
        isPublic: false
        isStatic: false // true if nested even without static modifier 
        isFinal: true
        isSealed: falsee
        isPrimitive: false
        getPermittedSubclasses: null
        */     

        cls = E.class;
        /*
        isPublic: false
        isStatic: false // true if nested even without static modifier 
        isFinal: true
        isSealed: false
        isPrimitive: false
        getPermittedSubclasses: null
        */     
        
        int modifier = cls.getModifiers();
        
        System.out.println(String.format("isPublic: %b", java.lang.reflect.Modifier.isPublic(modifier)));
        System.out.println(String.format("isStatic: %b", java.lang.reflect.Modifier.isStatic(modifier)));
        System.out.println(String.format("isFinal: %b", java.lang.reflect.Modifier.isFinal(modifier)));
        System.out.println(String.format("isSealed: %b", cls.isSealed()));
        System.out.println(String.format("isPrimitive: %b", cls.isPrimitive()));
        System.out.println(String.format("getPermittedSubclasses: %s", java.util.Arrays.toString(cls.getPermittedSubclasses())));
    }
    
    /*
    class C {}
    // sealed class SC {}
    // Or
    sealed class SC permits NSC {}
    non-sealed class NSC extends SC {}
    final class FC extends NSC implements SI {}

    interface I {}
    // sealed interface SI {}
    // Or
    sealed interface SI permits NSI, FC {}
    non-sealed interface NSI extends SI {}

    record R() {}
    final record FR() {}
    enum E {}
    */
}

class C {}
// sealed class SC {}
// Or
sealed class SC permits NSC {}
non-sealed class NSC extends SC {}
final class FC extends NSC implements SI {}

interface I {}
// sealed interface SI {}
// Or
sealed interface SI permits NSI, FC {}
non-sealed interface NSI extends SI {}

record R() {}
final record FR() {}
enum E {}
*/
/******************************************************************************/


/******************************************************************************/
// Java // record, enum, interface
/******************************************************************************/
/*
interface I {}
record R() implements I, java.io.Serializable {}
final record EFR() implements I, java.io.Serializable {}
enum E implements I, java.io.Serializable {}
*/
/******************************************************************************/


/******************************************************************************/
// Java // Nested Types // record, enum
/******************************************************************************/
/*
record OuterR() {
     class C {}
     record InnerR() {}
     enum E {}
     static class SC {}
     static record SInnerR() {}
     static enum SE {}
 }
 
 enum OuterE {
     Alpha,
     Beta,
     Gamma;
     
     class C {}
     record R() {}
     enum InnerE {}
     static class SC {}
     static record SR() {}
     static enum SInnerE {}
 }
*/
/******************************************************************************/


/******************************************************************************/
// Java // Nested Types
/******************************************************************************/
/*
class OuterClass {
    void outerClassMethod() {
        System.out.println("Outer class method");
        class InnerClassInOuterClassMethod {
            void innerClassMethod() {
                System.out.println("Inner class method, in inner class, in outer class method");
            }
        }
        InnerClassInOuterClassMethod classInner = new InnerClassInOuterClassMethod();
        classInner.innerClassMethod();
    }
}

public class Program {
     public static void main(String[] args) {
        OuterClass classOuter = new OuterClass();
        classOuter.outerClassMethod();
    }
}

class OC {
// interface OI {
// record OR() {
// enum OE { Etcetera;
    static class SC extends Object implements II, SI {}
    static class StaticC extends SC implements II, SI {}
    // static class can extend non-static class only when not in the same scope
    static class ScopeSC extends OC implements II, SI {}
    class NonStaticC extends SC implements II,SI {}
    class IC extends Object implements II, SI {}
    class ScopeC extends IC implements II, SI {}
    interface II {}
    interface ScopeI extends II {}
    static interface SI extends II {}
    static interface ScopeSI extends SI {}
    interface NonStaticI extends SI {}
    record IR() implements II, SI {}
    static record SR() implements II, SI {}
    enum IE implements II, SI {}
    static enum SE implements II, SI {}
}
// }}}
*/
/******************************************************************************/


/******************************************************************************/
// Java // Generics Wildcards
/******************************************************************************/
/*
class Program {
    public static void main(String args[]) {
       Program pro = new Program();
       pro.print();
    }

    public void print()
    {
        java.util.List<Integer> numbers = new java.util.ArrayList<Integer>();
        // error: illegal start of expression
        // <Integer>methodList(numbers);
        this.<Integer>methodList(numbers);
        // Or
        // methodList(numbers);
        
        // error: illegal start of expression
        // <Sample>methodClass(Sample.class);
        this.<Sample>methodClass(Sample.class);
        // Or
        // methodClass(Sample.class);
    }
    
    // public <T> void methodList(java.util.List<T> numbers) {}
    // Or
    public void methodList(java.util.List<?> numbers) {}
    
    public <T> void methodClass(Class<T> wildcard) {}
    // Or
    // public void methodClass(Class<?> wildcard) {}
}

class Sample {}
*/
/******************************************************************************/


/******************************************************************************/
// Java // Class<?>
/******************************************************************************/
/*
public class Program {
    public static void main(String args[]) {
      System.out.println(String.format("Java Version: %s\n", System.getProperty("java.version")));
       Program pro = new Program();
       pro.print();
    }

    public void print()
    {
        java.util.List<Integer> numbers = new java.util.ArrayList<Integer>();
        
        // methodList(numbers);
        // Or
        this.<Integer>methodList(numbers);
      
        /*
        // castMethodClass(Base.class);
        // Or
        this.<Class<Base>>castMethodClass(Base.class);
        */
        
        // methodClass(Base.class);
        // Or
        this.<Base>methodClass(Base.class);
    }
    
    // public <T> void methodList(java.util.List<T> numbers) {}
    // Or
    public void methodList(java.util.List<?> numbers) {}

    /*
    public <T> void castMethodClass(T t) {
        
        // Class<?> castToClassTypeLocal = (Class<?>)t;
        // Or
        // Class<?> castToClassTypeLocal = (Class<T>)t;
        // Or
        Class<T> castToClassTypeLocal = (Class<T>)t;
        
        // Class<?> wildcardLocal = new Standalone().getClass();
        Class<?> wildcardLocal = new Derived().getClass();
        
        boolean isTrue = castToClassTypeLocal.isAssignableFrom(wildcardLocal);
        
        System.out.println(String.format("%s isAssignableFrom %s: %b", castToClassTypeLocal, wildcardLocal, isTrue));
        
        boolean isFalse = wildcardLocal.isAssignableFrom(castToClassTypeLocal);
        
        System.out.println(String.format("%s isAssignableFrom %s: %b", wildcardLocal, castToClassTypeLocal, isFalse));
    }
    */
    
    /*
    public <T> void methodClass(Class<T> classTypePassed) {
        
        // Class<?> wildcardLocal = new Standalone().getClass();
        Class<?> wildcardLocal = new Derived().getClass();
        
        boolean isTrue = classTypePassed.isAssignableFrom(wildcardLocal);
        
        System.out.println(String.format("%s isAssignableFrom %s: %b", classTypePassed, wildcardLocal, isTrue));
        
        boolean isFalse = wildcardLocal.isAssignableFrom(classTypePassed);
        
        System.out.println(String.format("%s isAssignableFrom %s: %b", wildcardLocal, classTypePassed, isFalse));
    }
    */
    // Or
    public void methodClass(Class<?> wildcardPassed) {
        
        // Class<?> wildcardLocal = new Standalone().getClass();
        Class<?> wildcardLocal = new Derived().getClass();
        
        boolean isTrue = wildcardPassed.isAssignableFrom(wildcardLocal);
        
        System.out.println(String.format("%s isAssignableFrom %s: %b", wildcardPassed, wildcardLocal, isTrue));
        
        boolean isFalse = wildcardLocal.isAssignableFrom(wildcardPassed);
        
        System.out.println(String.format("%s isAssignableFrom %s: %b", wildcardLocal, wildcardPassed, isFalse));
    }
}

class Base {}

class Derived extends Base {}

class Standalone {}
*/
/******************************************************************************/


/******************************************************************************/
// CS // System.Type
/******************************************************************************/
/*
class Program
{
    static void Main() 
    {
        System.Console.WriteLine("System.Environment.Version: {0}\n", System.Environment.Version);
        Program pro = new Program();
        pro.Print();
    }
    
    public void Print()
    {
        System.Collections.Generic.List<int> numbers = new System.Collections.Generic.List<int>();
        // MethodList(numbers);
        // Or
        // this.MethodList<int>(numbers);
        // Or
        MethodList<int>(numbers);

        /*
        // CastMethodClass<System.Type>(typeof(Base));
        // Or
        // this.CastMethodClass(typeof(Base));
        // Or
        CastMethodClass<System.Type>(typeof(Base));
        */
        
        // this.MethodClass(typeof(Base));
        // Or
        MethodClass(typeof(Base));
    }
    
    public void MethodList<T>(System.Collections.Generic.List<T> numbers) {}
    
    /*
    public void CastMethodClass<T>(T t)
    {
        System.Type castToSystemTypeLocal = t as System.Type;
        
        // System.Type systemTypeLocal = new Standalone().GetType();
        System.Type systemTypeLocal = new Derived().GetType();
        
        bool isTrue = castToSystemTypeLocal.IsAssignableFrom(systemTypeLocal);
        
        System.Console.WriteLine("{0} IsAssignableFrom {1}: {2}", castToSystemTypeLocal, systemTypeLocal, isTrue);
    
        bool isFalse = systemTypeLocal.IsAssignableFrom(castToSystemTypeLocal);
        
        System.Console.WriteLine("{0} IsAssignableFrom {1}: {2}", systemTypeLocal, castToSystemTypeLocal, isFalse);
    }
    */
    
    public void MethodClass(System.Type systemTypePassed)
    {
        // System.Type systemTypeLocal = new Standalone().GetType();
        System.Type systemTypeLocal = new Derived().GetType();
        
        bool isTrue = systemTypePassed.IsAssignableFrom(systemTypeLocal);
        
        System.Console.WriteLine("{0} IsAssignableFrom {1}: {2}", systemTypePassed, systemTypeLocal, isTrue);
    
        bool isFalse = systemTypeLocal.IsAssignableFrom(systemTypePassed);
        
        System.Console.WriteLine("{0} IsAssignableFrom {1}: {2}", systemTypeLocal, systemTypePassed, isFalse);
    }
}

class Base {}

class Derived : Base {}

class Standalone {}
*/
/******************************************************************************/


/******************************************************************************/
// Java // CS // Subtleties
/******************************************************************************/
// Java // isPrimitive() 
/*
int i = 0;
// i.getClass().isPrimitive()
// error: int cannot be dereferenced
int.class.isPrimitive() is true
Integer n = 0;
n.getClass().isPrimitive() is false
E.class.isPrimitive() is false
E.Alpha.getClass().isPrimitive() is false
enum E { Alpha, Beta, Gamma }
*/

// CS // IsValueType
/*
int i = 0;
i.GetType().IsValueType is True
typeof(E).IsValueType is True
E.Alpha.GetType().IsValueType is True
enum E { Alpha, Beta, Gamma }
*/

// Java // static class
/*
// Can only be nested
// Can have static and/or instance members 
// Can have non-static and/or static nested classes
// Can extend Object/static class/non-static class (other than non-static class in the same scope), and implement interface
// Can be extended by static/non-static class 
*/

// CS // static class 
/*
// Need not be nested
// Can have only static members
// Can have non-static and/or static nested classes
// Can extend only object, cannot implement interface, and cannot be extended 
// NB
// CS struct cannot be extended nor extend object, however struct other than ref struct can implement interface(s) 

// Java record  // Reference Type 
/*
// record expects header ()
// record are final and can be explicitly declared final, hence cannot extend 
// record can implement interface(s)
*/

// Java enum // Reference Type 
/*
// enum is final although can't be explicitly declared, hence cannot extend 
// enum can implement interface(s)
*/

// Java // final
/*
// final can be method parameter and/or local unlike CS local const
*/

// Java // Unbounded Wildcards
/*
// Wildcard character (?)
// E.g. List<?>, Class<?>, etc
// Two scenarios:
// 1. List<Object> (using functionality provided in the Object class): Only a list of Object instances and not List<Integer>, List<String>, List<Double>, etc.
// 2. List<?> (using methods in the generic class that don't depend on the type parameter): A list of any type List<Integer>, List<String>, List<Double>, etc. And for Class<?>, most of the methods in Class<T> do not depend on T.
*/
// Java // Upper Bounded Wildcards
/*
// Wildcard character ('?'), followed by the extends/implements keyword, followed by its upper bound: <? extends/implements X>.
/// E.g., List<Number> is more restrictive than List<? extends Number> because the former matches a list of type Number only, whereas the latter matches a list of type Number or any of its subclasses.
*/
// Java // Lower Bounded Wildcards
/*
// Wildcard character ('?'), following by the super keyword, followed by its lower bound: <? super X>.
// E.g., List<Integer> is more restrictive than List<? super Integer> because the former matches a list of type Integer only, whereas the latter matches a list of any type that is a supertype of Integer.
*/
// Note: Java Bounded Wildcards
/*
// You can specify an upper bound for a wildcard, or you can specify a lower bound, but you cannot specify both.
*/

// Java // Arrays.toString(), Arrays.deepToString()
/*
int[] intArray = new int[]{1, 2, 3, 4, 5, 6};
String[] objArray = new String[]{"Java", "Python", "JavaScript"};

// If using Stream.of(), primitive types need to be flatmapped
Stream.of(intArray).flatMapToInt(Arrays::stream).forEach(System.out::print);
IntStream.of(intArray).forEach(System.out::print);
// Stream.of() with objects
Stream.of(objArray).forEach(System.out::print);

// Arrays.stream() works with both primitive types and objects
Arrays.stream(intArray).forEach(System.out::print);
Arrays.stream(objArray).forEach(System.out::print);

// If using asList(), primitive types need to be flatMapped
Arrays.asList(intArray).stream().flatMapToInt(Arrays::stream).forEach(System.out::print);
Arrays.asList(objArray).stream().forEach(System.out::print);
*/
/******************************************************************************/


/******************************************************************************/
// CS // Multidimensional Array
/******************************************************************************/
// Three-dimensional Array
// 2 * 4 * 6 = 48 elements
int[ , , ] array3D = new int[2, 4, 6]; // int[ , , , ] array4D = new int[8, 6, 4, 2]; . . .

for (int i = 0; i < array3D.GetLength(0); i++)
{
    for (int j = 0; j < array3D.GetLength(1); j++)
    {
        for (int k = 0; k < array3D.GetLength(2); k++)
        {
            array3D[i, j, k] = Random.Shared.Next();
        }
    }
}

for (int i = 0; i < array3D.GetLength(0); i++)
{
    for (int j = 0; j < array3D.GetLength(1); j++)
    {
        for (int k = 0; k < array3D.GetLength(2); k++)
        {
            Console.WriteLine($"array3D[{i}, {j} , {k}] = {array3D[i, j, k]}");
        }
    }
}
*/
/******************************************************************************/


/******************************************************************************/
// Java // Multidimensional Array
/******************************************************************************/
/*
// Three-dimensional Array
public class Program {
    public static void main(String args[]) {
        // 2 * 4 * 6 = 48 elements
        int[][][] array3D = new int[2][4][6]; // int[][][][] array4D = new int[7][5][3][1]; . . .
        for (int i = 0; i < array3D.length; i++) {
            for (int j = 0; j < array3D[i].length; j++) {
                for (int k = 0; k < array3D[i][j].length; k++) {
                    array3D[i][j][k] = new java.util.Random().nextInt(100);
                }
            }
        }
        
        
        for (int i = 0; i < array3D.length; i++) {
            for (int j = 0; j < array3D[i].length; j++) {
                for (int k = 0; k < array3D[i][j].length; k++) {
                    System.out.printf("array3D[%d][%d][%d] = %d\n", i, j, k, array3D[i][j][k]);
                }
            }
        }


        // for each loop
        // for (int[][] array2D: array3D) {
            // for (int[] array1D: array2D) {
                // for(int element: array1D) {
                    // System.out.println(element);
                // }
            // }
        // }

    }
}
*/
/******************************************************************************/


/******************************************************************************/
// CS // Jagged Arrays
/******************************************************************************/
/*
// Jagged Array
int[][] jaggedArray = new int[2][];  // int[][][] jaggedArray = new int[2][][]; . . .

// 4 + 8 = 12 elements
for (int i = 0; i < jaggedArray.Length; i++)
{
    jaggedArray[0] = new int[4]; // jaggedArray[0] = new int[10]; . . .
    jaggedArray[1] = new int[8]; // jaggedArray[1] = new int[5]; . . .
}

#if comment
for (int i = 0; i < jaggedArray[0].Length; i++)
{
    jaggedArray[0][i] = Random.Shared.Next();
}

for (int i = 0; i < jaggedArray[1].Length; i++)
{
    jaggedArray[1][i] = Random.Shared.Next();
}
#endif

for (int i = 0; i < jaggedArray.Length; i++)
{
    for (int j = 0; j < jaggedArray[i].Length; j++)
    {
        jaggedArray[i][j] = Random.Shared.Next();
    }
}

#if comment
for (int i = 0; i < jaggedArray[0].Length; i++)
{
    Console.WriteLine($"jaggedArray[{0}][{i}] = {jaggedArray[0][i]}");
}

for (int i = 0; i < jaggedArray[1].Length; i++)
{
    Console.WriteLine($"jaggedArray[{1}][{i}] = {jaggedArray[1][i]}");
}
#endif

for (int i = 0; i < jaggedArray.Length; i++)
{
    for (int j = 0; j < jaggedArray[i].Length; j++)
    {
        Console.WriteLine($"jaggedArray[{i}][{j}] = {jaggedArray[i][j]}");
    }
}
*/


/*
// Jagged Array with Multidimensional Arrays
// Jagged Array with Three-dimensional Arrays
int[][ , , ] jaggedArray = new int[2][ , , ];  // int[][ , , ][ , , , ] jaggedArray = new int[4][ , , ][ , , , ]; . . .

// (2 * 4 * 6) + (5 * 3 * 1) = 63 elements
for (int i = 0; i < jaggedArray.Length; i++)
{
    jaggedArray[0] = new int[2, 4, 6];
    jaggedArray[1] = new int[5, 3, 1];
}

#if comment
for (int i = 0; i < jaggedArray[0].GetLength(0); i++)
{
    for (int j = 0; j < jaggedArray[0].GetLength(1); j++)
    {
        for (int k = 0; k < jaggedArray[0].GetLength(2); k++)
        {
            jaggedArray[0][i, j, k] = Random.Shared.Next();
        }
    }
}

for (int i = 0; i < jaggedArray[1].GetLength(0); i++)
{
    for (int j = 0; j < jaggedArray[1].GetLength(1); j++)
    {
        for (int k = 0; k < jaggedArray[1].GetLength(2); k++)
        {
            jaggedArray[1][i, j, k] = Random.Shared.Next();
        }
    }
}
#endif

for (int index = 0; index < jaggedArray.Length; index++)
{
    for (int i = 0; i < jaggedArray[index].GetLength(0); i++)
    {
        for (int j = 0; j < jaggedArray[index].GetLength(1); j++)
        {
            for (int k = 0; k < jaggedArray[index].GetLength(2); k++)
            {
                jaggedArray[index][i, j, k] = Random.Shared.Next();
            }
        }
    }
}

#if comment
for (int i = 0; i < jaggedArray[0].GetLength(0); i++)
{
    for (int j = 0; j < jaggedArray[0].GetLength(1); j++)
    {
        for (int k = 0; k < jaggedArray[0].GetLength(2); k++)
        {
            Console.WriteLine($"jaggedArray[0][{i}, {j} , {k}] = {jaggedArray[0][i, j, k]}");
        }
    }
}

for (int i = 0; i < jaggedArray[1].GetLength(0); i++)
{
    for (int j = 0; j < jaggedArray[1].GetLength(1); j++)
    {
        for (int k = 0; k < jaggedArray[1].GetLength(2); k++)
        {
            Console.WriteLine($"jaggedArray[1][{i}, {j} , {k}] = {jaggedArray[1][i, j, k]}");
        }
    }
}
#endif

for (int index = 0; index < jaggedArray.Length; index++)
{
    for (int i = 0; i < jaggedArray[index].GetLength(0); i++)
    {
        for (int j = 0; j < jaggedArray[index].GetLength(1); j++)
        {
            for (int k = 0; k < jaggedArray[index].GetLength(2); k++)
            {
                Console.WriteLine($"jaggedArray[{index}][{i}, {j} , {k}] = {jaggedArray[index][i, j, k]}");
            }
        }
    }
}
*/
/******************************************************************************/


/******************************************************************************/
// Java // Array 
/******************************************************************************/
/*
// Java // Array concat
public class Program {
    public static void main(String args[]) {
        int[] a = { 1, 3, 5 };
        int[] b = { 0, 2, 3, 6 };
        a = java.util.stream.IntStream
            .concat(java.util.stream.IntStream.of(a), java.util.stream.IntStream.of(b))
            .sorted()
            .toArray();
        System.out.println(java.util.Arrays.toString(a));
    }
}
*/

/*
// Java // Array concat distinct
public class Program {
    public static void main(String args[]) {
        int[] a = { 1, 3, 5 };
        int[] b = { 0, 2, 3, 6 };
        a = java.util.stream.IntStream
            .concat(java.util.stream.IntStream.of(a), java.util.stream.IntStream.of(b))
            .distinct()
            .sorted()
            .toArray();
        System.out.println(java.util.Arrays.toString(a));
    }
}
*/

/*
// Java // Array concat // for loop 
public class Program {
    public static void main(String args[]) {
        int[] a = { 1, 3, 5 };
        int[] b = { 0, 2, 3, 6 };
        int originalLength = a.length;
        a = java.util.Arrays.copyOf(a, a.length + b.length);
        for (int i = originalLength, j = 0; j < b.length; i++, j++) {
            a[i] = b[j];
        }
        System.out.println(java.util.Arrays.toString(a));
    }
}
*/

/*
// Java // Array Copy
public class Program {
    public static void main(String args[]) {
        int[] a = { 1, 3, 5 };
        int[] b = { 0, 2, 3, 6 };
        a = new int[b.length];
        System.arraycopy(b, 0, a, 0, b.length );
        System.out.println(java.util.Arrays.toString(a));
    }
}
*/
/******************************************************************************/


/******************************************************************************/
// CS // Array
/******************************************************************************/
/*
// CS // Array Concatenation
// using System.Linq;
int[] a = { 1, 3, 5 };
int[] b = { 0, 2, 3, 6 };
var c = a.Concat(b).OrderBy(x => x);
Console.WriteLine(string.Join(", ", c));
*/

/*
// CS // Array.Resize, Array.Copy, and Array.Sort
// using System.Array;
// using System.Linq;
int[] a = { 1, 3, 5 };
int[] b = { 0, 2, 3, 6 };
int array1OriginalLength = a.Length;
Array.Resize<int>(ref a, array1OriginalLength + b.Length);
Array.Copy(b, 0, a, array1OriginalLength, b.Length);
Array.Sort(a);
Console.WriteLine(string.Join(", ", a));
*/

/*
// CS // Array.Resize, Array.Copy, Array.Sort, and new Array
// using System.Array;
// using System.Linq;
int[] a = { 1, 3, 5 };
int[] b = { 0, 2, 3, 6 };
int[] c = new int[a.Length + b.Length];
Array.Copy(a, c, a.Length);
Array.Copy(b, 0, c, a.Length, b.Length);
Array.Sort(c);
Console.WriteLine(string.Join(", ", c));
*/
/******************************************************************************/


/******************************************************************************/
// Java // String // Reverse
/******************************************************************************/
/*
// 1. java.util.stream.Stream.of
String text = "Reverse a string!";
String reversedText = java.util.stream.Stream.of(text)
    .map(string -> new StringBuilder(string).reverse())
    .collect(java.util.stream.Collectors.joining());
System.out.println(reversedText);
*/

/*
// 2. java.util.stream.IntStream.range and java.lang.StringBuilder
String text = "Reverse a string!";
String reversedText = java.util.stream.IntStream.range(0, text.length())
    .mapToObj(i -> text.toCharArray()[text.length() - i - 1])
    .collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();
System.out.println(reversedText);
*/

/*
// 3. java.lang.StringBuilder
String text = "Reverse a string!";
String reversedText = new StringBuilder(text).reverse() .toString();
System.out.println(reversedText);
*/

/*
// 4. String.chars
String text = "Reverse a string!";
String reversedText = text.chars()
    .mapToObj(x -> (char) x)
    .reduce("", (a, b) -> b + a, (c, d) -> d + c);
System.out.println(reversedText);
*/

/*
// 5. for loop
String text = "Reverse a string!";
String reversedText = "";
for (int i = text.length() - 1; i >= 0; i--) {
    reversedText = reversedText + text.charAt(i);
}
System.out.println(reversedText);
*/
/******************************************************************************/


/******************************************************************************/
// CS // string // Reverse
/******************************************************************************/
/*
// 1. using System.Linq;
string text = "Reverse a string!";
string reversedText = new string(Enumerable.Range(1, text.Length).Select(i => text[text.Length - i]).ToArray());
Console.WriteLine(reversedText);
*/

/*
// 2. using System.Text; // StringBuilder
string text = "Reverse a string!";
string reversedText = new string(new System.Text.StringBuilder().Append(text).ToString().Reverse().ToArray());
Console.WriteLine(reversedText);
*/

/*
// 3. String.ToCharArray
string text = "Reverse a string!";
char[] chararray = text.ToCharArray();
Array.Reverse(chararray);
string reversedText = new string(chararray);
Console.WriteLine(reversedText);
*/
/******************************************************************************/


/******************************************************************************/
// Java // Access Private Method
/******************************************************************************/
/*
public class Program {
  public static void main(String args[]) throws Exception { //
    // try {
      var inquisite = new Inquisitive();
      inquisite.print();
    // } catch (Exception e) {
      // e.printStackTrace();
    // }
  }
}

class PrivateType {
  private static void staticcMethod() {
    System.out.println("Private static method");
  }

  private void instanceMethod() {
    System.out.println("Private instance method");
  }
}

class Inquisitive {
  public void print() throws Exception { //
    // try {
      Class classForName = Class.forName("PrivateType");
      Object instance = classForName.newInstance();
      java.lang.reflect.Method meth = instance.getClass().getDeclaredMethod("staticcMethod");
      meth.setAccessible(true);
      meth.invoke(instance);
      meth = instance.getClass().getDeclaredMethod("instanceMethod");
      meth.setAccessible(true);
      meth.invoke(instance);
    // } catch (ClassNotFoundException e) {
      // e.printStackTrace();
    // } catch (InstantiationException e) {
      // e.printStackTrace();
    // } catch (IllegalAccessException e) {
      // e.printStackTrace();
    // } catch (NoSuchMethodException e) {
      // e.printStackTrace();
    // } catch (java.lang.reflect.InvocationTargetException e) {
      // e.printStackTrace();
    // }
  }
}
*/
/******************************************************************************/


/******************************************************************************/
// CS // Access Private Method
/******************************************************************************/
/*
Inquisitive inquisite = new();
inquisite.Print();

class PrivateType
{
    private static void StaticcMethod()
    {
        Console.WriteLine("Private static method");
    }

    private void InstanceMethod()
    {
        Console.WriteLine("Private instance method");
    }
}

class Inquisitive
{
    public void Print()
    {
        typeof(PrivateType).GetMethod("StaticcMethod", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static)?.Invoke(new PrivateType(), null);
        typeof(PrivateType).GetMethod("InstanceMethod", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)?.Invoke(new PrivateType(), null);
    }
}
*/
/******************************************************************************/


/******************************************************************************/
// Java // enum
/******************************************************************************/
// % java Planet.java 1
/*
enum Planet {
    MERCURY (3.303e+23, 2.4397e6),
    VENUS   (4.869e+24, 6.0518e6),
    EARTH   (5.976e+24, 6.37814e6),
    MARS    (6.421e+23, 3.3972e6),
    JUPITER (1.9e+27,   7.1492e7),
    SATURN  (5.688e+26, 6.0268e7),
    URANUS  (8.686e+25, 2.5559e7),
    NEPTUNE (1.024e+26, 2.4746e7);

    private final double mass;   // in kilograms
    private final double radius; // in meters
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
    }
    private double mass() { return mass; }
    private double radius() { return radius; }

    // universal gravitational constant  (m3 kg-1 s-2)
    public static final double G = 6.67300E-11;

    double surfaceGravity() {
        return G * mass / (radius * radius);
    }
    double surfaceWeight(double otherMass) {
        return otherMass * surfaceGravity();
    }
    public static void main(String[] args) {
        if (args.length != 1) {
            System.err.println("Usage: java Planet <earth_weight>");
            System.exit(-1);
        }
        double earthWeight = Double.parseDouble(args[0]);
        double mass = earthWeight/EARTH.surfaceGravity();
        for (Planet p : Planet.values()) {
           System.out.printf("Your weight on %s is %f%n",
               p, p.surfaceWeight(mass));
        }
    }
}
*/
/******************************************************************************/


/******************************************************************************/
// Java // System Properties
/******************************************************************************/
/*
public class Program {
    public static void main(String args[]) {
         Program pro = new Program();
         pro.printSystemProperties();
    }
    
    public void printSystemProperties() {
      System.out.println(String.format("OS Name: %s", System.getProperty("os.name")));
      System.out.println(String.format("OS Version: %s", System.getProperty("os.version")));
      System.out.println(String.format("OS Architecture: %s", System.getProperty("os.arch")));
      System.out.println(String.format("Java Version: %s", System.getProperty("java.version")));
      // System.out.println(String.format("Java Home: %s", System.getProperty("java.home")));
      // System.out.println(String.format("User Name: %s", System.getProperty("user.name")));
      // System.getProperties().list(System.out);
    }
}
*/
/******************************************************************************/


/******************************************************************************/
// CS // System.Environment
/******************************************************************************/
/*
using System;
using System.Runtime.InteropServices;

EnvironmentProperties propertiesEnvironment = new();
propertiesEnvironment.Print();

class EnvironmentProperties
{
    public void Print()
    {
        // using System;
        Console.WriteLine($"Environment.OSVersion: {Environment.OSVersion}");
        Console.WriteLine($"Environment.OSVersion.Platform: {Environment.OSVersion.Platform}");
        Console.WriteLine($"Environment.OSVersion.Version: {Environment.OSVersion.Version}");
        Console.WriteLine($"Environment.OSVersion.VersionString: {Environment.OSVersion.VersionString}");
        Console.WriteLine($"Environment.OSVersion.Version.Major: {Environment.OSVersion.Version.Major}");
        Console.WriteLine($"Environment.OSVersion.Version.Minor: {Environment.OSVersion.Version.Minor}");
        // Empty
        // Console.WriteLine($"Environment.OSVersion.ServicePack: {Environment.OSVersion.ServicePack}");

        // Environment.Version property returns the .NET runtime version for .NET 5+ and .NET Core 3.x
        // Not recommend for .NET Framework 4.5+
        Console.WriteLine($"Environment.Version: {Environment.Version}");
        //  <-- Keep this information secure! -->
        // Console.WriteLine($"Environment.UserName: {Environment.UserName}");

        //  <-- Keep this information secure! -->
        // Console.WriteLine($"Environment.MachineName: {Environment.MachineName}");

        //  <-- Keep this information secure! -->
        // Console.WriteLine($"Environment.UserDomainName: {Environment.UserDomainName}");

        Console.WriteLine($"Environment.Is64BitOperatingSystem: {Environment.Is64BitOperatingSystem}");
        Console.WriteLine($"Environment.Is64BitProcess: {Environment.Is64BitProcess}");

        //  <-- Keep this information secure! -->
        // Console.WriteLine("CurrentDirectory: {0}", Environment.CurrentDirectory);
        //  <-- Keep this information secure! -->
        // Console.WriteLine("SystemDirectory: {0}", Environment.SystemDirectory);

        // RuntimeInformation.FrameworkDescription property gets the name of the .NET installation on which an app is running
        // .NET 5+ and .NET Core 3.x // .NET Framework 4.7.1+ // Mono 5.10.1+
        // using System.Runtime.InteropServices;
        Console.WriteLine($"RuntimeInformation.FrameworkDescription: {RuntimeInformation.FrameworkDescription}");

        Console.WriteLine($"RuntimeInformation.ProcessArchitecture: {RuntimeInformation.ProcessArchitecture}");
        Console.WriteLine($"RuntimeInformation.OSArchitecture: {RuntimeInformation.OSArchitecture}");
        Console.WriteLine($"RuntimeInformation.OSDescription): {RuntimeInformation.OSDescription}");
        // .NET Mono 6.12.0 does not contain a definition for `RuntimeIdentifier'
        Console.WriteLine($"RuntimeInformation.RuntimeIdentifier: {RuntimeInformation.RuntimeIdentifier}");

        // <-- Keep this information secure! -->
#if comments
        Console.WriteLine("Environment Variables:");
        foreach (System.Collections.DictionaryEntry de in Environment.GetEnvironmentVariables())
        {
            Console.WriteLine("{0} = {1}", de.Key, de.Value);
        }
#endif
        Console.WriteLine();
    }
}
*/
/******************************************************************************/


/******************************************************************************/
// CS 11 // Subject to updates in newer versions of CS
/******************************************************************************/
// Version
/******************************************************************************/
using static System.Runtime.InteropServices.JavaScript.JSType;

var os = Environment.OSVersion;
Console.WriteLine("OS Information:");
Console.WriteLine("Platform: {0:G}", os.Platform);
Console.WriteLine("Version String: {0}", os.VersionString);
Console.WriteLine("Version Information:");
Console.WriteLine("   Major: {0}", os.Version.Major);
Console.WriteLine("   Minor: {0}", os.Version.Minor);
Console.WriteLine("Service Pack: '{0}'", os.ServicePack);

// Environment.Version property returns the .NET runtime version for .NET 5+ and .NET Core 3.x
// Not recommend for .NET Framework 4.5+
Console.WriteLine($"Environment.Version: {Environment.Version}");
// RuntimeInformation.FrameworkDescription property gets the name of the .NET installation on which an app is running
// .NET 5+ and .NET Core 3.x // .NET Framework 4.7.1+ // Mono 5.10.1+
Console.WriteLine($"RuntimeInformation.FrameworkDescription: {System.Runtime.InteropServices.RuntimeInformation.FrameworkDescription}");
Console.WriteLine();
/******************************************************************************/


// interface, static, generic interface, static abstract, static virtual
/******************************************************************************/
Console.WriteLine(IStatic.Constant);
Console.WriteLine(IStatic.StaticField);
Console.WriteLine(IStatic.StaticReadOnlyField);
Console.WriteLine(IStatic.StaticVolatileField);

Console.WriteLine(IStatic.StaticProperty);
IStatic staticI = new StaticImplementation();
Console.WriteLine(staticI.InstanceProperty);
Console.WriteLine(staticI.AbstractProperty);
Console.WriteLine(staticI.VirtualProperty);
IStatic.StaticMethod();
staticI.InstanceMethod();
staticI.AbstractMethod();
staticI.VirtualMethod();

// CS 11
// A static virtual or abstract interface member can be accessed only on a type parameter
// Console.WriteLine(IStaticGeneric<StaticGenericImplementation>.StaticAbstractProperty);
// IStaticGeneric<StaticGenericImplementation>.StaticAbstractMethod();
// Console.WriteLine(IStaticGeneric<StaticGenericImplementation>.StaticVirtualProperty);
//IStaticGeneric<StaticGenericImplementation>.StaticVirtualMethod();
Console.WriteLine(StaticGenericImplementation.StaticAbstractProperty);
StaticGenericImplementation.StaticAbstractMethod();
Console.WriteLine(StaticGenericImplementation.StaticVirtualProperty);
StaticGenericImplementation.StaticVirtualMethod();

// Note IStatic has no setter for the virtual indexer this[int i, int j, int k], otherwise the interface instance staticI can also be indexed
StaticImplementation implementationStatic = new();
// Random rand = new Random();
// .NET	6+
// Provides a thread-safe Random instance that may be used concurrently from any thread.
Random rand = Random.Shared;

// Elements 2
for (int i = 0; i < 2; i++)
{
    staticI[i] = rand.Next();
    // implementationStatic[i] = rand.Next();
}
for (int i = 0; i < 2; i++)
{
    Console.WriteLine($"Element #{i} = {staticI[i]}");
    // Console.WriteLine($"Element #{i} = {implementationStatic[i]}");
}

// Elements 2 x 3
for (int i = 0; i < 2; i++)
{
    for (int j = 0; j < 3; j++)
    {
        staticI[i, j] = rand.Next();
        // implementationStatic[i, j] = rand.Next();
    }
}
for (int i = 0; i < 2; i++)
{
    for (int j = 0; j < 3; j++)
    {
        Console.WriteLine($"Element #{i}, {j} = {staticI[i, j]}");
        // Console.WriteLine($"Element #{i}, {j} = {implementationStatic[i, j]}");
    }
}

// Elements 2 x 3 x 4
for (int i = 0; i < 2; i++)
{
    for (int j = 0; j < 3; j++)
    {
        for (int k = 0; k < 4; k++)
        {
            staticI[i, j, k] = rand.Next();
            // implementationStatic[i, j, k] = rand.Next();
        }
    }
}
for (int i = 0; i < 2; i++)
{
    for (int j = 0; j < 3; j++)
    {
        for (int k = 0; k < 4; k++)
        {
            Console.WriteLine($"Element #{i}, {j}, {k} = {staticI[i, j, k]}");
            // Console.WriteLine($"Element #{i}, {j}, {k} = {implementationStatic[i, j, k]}");
        }
    }
}

EventClient clientEvent = new();
IStatic.StaticEvent += clientEvent.ReceiveInterfaceEvent;
IStatic.StaticEventWithAccessors += clientEvent.ReceiveInterfaceEvent;
staticI.RaisetStaticEvent();
staticI.RaisetStaticEventWithAccessors();

implementationStatic.InstanceEvent += clientEvent.ReceiveInterfaceEvent;
implementationStatic.InstanceEventPlaceHolderExplicit += clientEvent.ReceiveInterfaceEvent;
implementationStatic.RaiseImplicitInstanceeEvent();
implementationStatic.RaiseExplicitInstanceeEvent();


// CS 11
// A static virtual or abstract interface member can be accessed only on a type parameter
// IStaticGeneric<StaticGenericImplementation>.StaticAbstractEvent += clientEvent.ReceiveInterfaceEvent;
// IStaticGeneric<StaticGenericImplementation>.StaticVirtualEvent += clientEvent.ReceiveInterfaceEvent;
// IStaticGeneric<StaticGenericImplementation>.StaticVirtualEventWithAccessors += clientEvent.ReceiveInterfaceEvent;
StaticGenericImplementation implementationStaticGeneric = new();
StaticGenericImplementation.StaticAbstractEvent += clientEvent.ReceiveInterfaceEvent;
StaticGenericImplementation.StaticAbstractEventPlaceHolderExplicit += clientEvent.ReceiveInterfaceEvent;
implementationStaticGeneric.RaisetImplicitStaticAbstractEvent();
implementationStaticGeneric.RaisetExplicitStaticAbstractEvent();

StaticGenericImplementation.StaticVirtualEvent += clientEvent.ReceiveInterfaceEvent;
StaticGenericImplementation.StaticVirtualEventPlaceHolderExplicit += clientEvent.ReceiveInterfaceEvent;
implementationStaticGeneric.RaisetImplicitStaticVirtualEvent();
implementationStaticGeneric.RaisetExplicitStaticVirtualEvent();


implementationStaticGeneric.StaticVirtualEventWithAccessors += clientEvent.ReceiveInterfaceEvent;
StaticGenericImplementation.StaticVirtualEventWithAccessorsPlaceHolderImplementationExplicit += clientEvent.ReceiveInterfaceEvent;
implementationStaticGeneric.RaisetImplicitStaticVirtualEventWithAccessors();
implementationStaticGeneric.RaisetExplicitStaticVirtualEventWithAccessors();


OperatorImplementation implementationOperator = new();
Console.WriteLine($"nameof: {nameof(implementationOperator)}");
Console.WriteLine($"GetType: {implementationOperator.GetType()}");
Console.WriteLine($"typeof: {typeof(OperatorImplementation)}");
Console.WriteLine($"typeof GetType: {typeof(OperatorImplementation).GetType()}");
Console.WriteLine($"IsValueType: {typeof(OperatorImplementation).IsValueType}");
Console.WriteLine("overloading unary operator ++");
for (int i = 0; i < 26; i++)
{
    Console.WriteLine(++implementationOperator);
}
Console.WriteLine("overloading unary operator --");
for (int i = 0; i < 26; i++)
{
    Console.WriteLine(--implementationOperator);
}
/******************************************************************************/


// interface, static, generic interface, static abstract, static virtual
/******************************************************************************/
class InterfaceEventArgs : EventArgs // .NET Compliant
{
    public InterfaceEventArgs(string text) { Text = text; }
    public string Text { get; } // readonly
}

delegate void InterfaceEventHandler(object sender, InterfaceEventArgs e);

class EventClient
{
    public void ReceiveInterfaceEvent(object sender, InterfaceEventArgs args)
    {
        Console.WriteLine($"Event received by {this} object: {args.Text}");
        Console.WriteLine($"Source: {sender}");
    }
}

interface IStatic
{
    // NB
    // For interface data/function members, hiding will be intended only in the inheriting inteface, however not in the implementing type viz. class, struct, or record

    // interface data members
    // const
    // static field

    // Interface members are public by default because the purpose of an interface is to enable other types to access a class or struct.
    // CS 8
    // Interface member declarations may include any access modifier viz. public, protected, internal, protected internal, private protected, private.
    // This is most useful for static methods to provide common implementations needed by all implementors of a class.
    const string Constant = "const in interface";
    static string StaticField;
    static readonly string StaticReadOnlyField;
    static volatile string StaticVolatileField;

    // interface function members
    // static constructor
    // static/instance/abstract/virtual property
    // static/instance/abstract/virtual method
    // instance/abstract/virtual indexer
    // event
    // operator

    static IStatic()
    {
        StaticField = "static feild in interface";
        StaticReadOnlyField = "static readonly feild in interface";
        StaticVolatileField = "static volatile feild in interface";
        StaticProperty = "static property in interface";
    }


    // not found among members of the interface that can be implemented
    // although the implementing type can have simililar static property with the same name
    // interface static property can have initializers
    static string StaticProperty { get; set; } = "interface static property can have initializers";

    // interface instance property must be (implicitly or explicitly) implemented in the implementing type
    // interface instance property cannot have initializers
    string InstanceProperty { get; set; }

    // interface abstract property must be (implicitly or explicitly) implemented in the implementing type without the override keyword
    abstract string AbstractProperty { get; set; }

    // optional to implement interface virtual property (implicitly or explicitly) in the implementing type, however without the override keyword if implemented 
    //virtual string VirtualProperty =>  "interface virtual property can have initializers without explict accessors";
    static string setValue = "interface virtual property can have initializers";
    virtual string VirtualProperty
    {
        get { return setValue; }
        set { setValue = value; }
    }

    // CS 8
    // (default) static method implementation
    static void StaticMethod()
    {
        const string localConstant = "local const in interface (default) static method"; ;
        Console.WriteLine(localConstant);
    }

    // CS 8
    // (default) instance method implementation
    void InstanceMethod()
    {
        const string localConstant = "local const in interface (default) instance method"; ;
        Console.WriteLine(localConstant);
    }

    // interface abstract method must be implemented (implicitly or explicitly) in the implementing type without the override keyword
    abstract void AbstractMethod();

    // optional to implement interface virtual method (implicitly or explicitly) in the implementing type, however without the override keyword if implemented 
    virtual void VirtualMethod()
    {
        const string localConstant = "local const in interface virtual method"; ;
        Console.WriteLine(localConstant);
    }


    // NB
    // modifier 'static' is not valid for 'this'
    // interface instance indexer must be (implicitly or explicitly) implemented in the implementing type 
    int this[int i] { get; set; }
    // interface abstract indexer must be (implicitly or explicitly) implemented in the implementing type without the override keyword
    abstract int this[int i, int j] { get; set; }
    // optional to implement interfaace virtual indexer (implicitly or explicitly) in the implementing type, however without the override keyword if implemented 
    static int[, ,] array = new int[1, 1, 1];
    virtual int this[int i, int j, int k]
    {
        get { return array[i, j, k]; }
        set { array[i, j, k] = i; }
    }

    // not found among members of the interface that can be implemented
    static event InterfaceEventHandler? StaticEvent;

    static event InterfaceEventHandler? StaticEventWithAccessorsPlaceHolder;
    static event InterfaceEventHandler? StaticEventWithAccessors
    {
        add
        {
            StaticEventWithAccessorsPlaceHolder += value;
        }
        remove
        {
            StaticEventWithAccessorsPlaceHolder -= value;
        }
    }

    // NB
    // Wrap event invocations inside a protected virtual method
    // to allow derived classes to override the event invocation behavior
    void RaisetStaticEvent()
    {
        StaticEvent?.Invoke(this, new InterfaceEventArgs("Raise interface static event in the interface!"));
    }

    // NB
    // Wrap event invocations inside a protected virtual method
    // to allow derived classes to override the event invocation behavior
    void RaisetStaticEventWithAccessors()
    {
        StaticEventWithAccessorsPlaceHolder?.Invoke(this, new InterfaceEventArgs("Raise interface static event with accessors in the interface!"));
    }

    // interface instance event must be (implicitly or explicitly) implemented in the implementing type
    event InterfaceEventHandler? InstanceEvent;

    // not found among members of the interface that can be implemented
    static IStatic operator ++(IStatic staticI) => staticI;
}

// CS 11
// The static virtual and static abstract methods declared in interfaces don't have a runtime dispatch mechanism analogous to virtual or abstract methods declared in classes.
// Instead, the compiler uses type information available at compile time.
// Therefore, static virtual methods are almost exclusively declared in generic interfaces.
// Furthermore, most interfaces that declare static virtual or static abstract methods declare that one of the type parameters must implement the declared interface. 
interface IStaticGeneric<T> where T : IStaticGeneric<T>
{
    // interface function members
    // static abstract/static virtual property
    // static abstract/static virtual method

    // CS 11
    // static abstract only in interface
    // interface static abstract property must be implemented (implicitly or explicitly) in the implementing type without the override keyword
    static abstract string StaticAbstractProperty { get; set; }

    // CS 11
    // static abstract only in interface
    // interface static abstract method must be implemented (implicitly or explicitly) in the implementing type without the override keyword
    static abstract void StaticAbstractMethod();

    // CS 11
    // static virtual only in interface
    // optional to implement interfaace static virtual property in the implementing type, however without the override keyword if implemented 
    static virtual string StaticVirtualProperty { get; set; } = "static virtual property initialized in the interface";

    // CS 11
    // static virtual only in interface
    // optional to implement interface static virtual method in the implementing type, however without the override keyword if implemented 
    static virtual void StaticVirtualMethod()
    {
        const string localConstant = "local const in interface static virtual method"; ;
        Console.WriteLine(localConstant);
    }


    // CS 11
    // static abstract only in interface
    // interface static abstract event must be implemented (implicitly or explicitly) in the implementing type without the override keyword
    // interface static abstract event cannot use event accessor syntax
    static abstract event InterfaceEventHandler? StaticAbstractEvent;

    // CS 11
    // static virtual only in interface
    // optional to implement interface static virtual event (implicitly or explicitly) in the implementing type, however without the override keyword if implemented 
    static virtual event InterfaceEventHandler? StaticVirtualEvent;

    static event InterfaceEventHandler? StaticVirtualEventWithAccessorsPlaceHolder;

    // CS 11
    // static virtual only in interface
    // optional to implement interface static virtual event (implicitly or explicitly) in the implementing type, however without the override keyword if implemented 
    // interface static virtual event can use event accessor syntax
    static virtual event InterfaceEventHandler? StaticVirtualEventWithAccessors
    {
        add
        {
            StaticVirtualEventWithAccessorsPlaceHolder += value;
        }
        remove
        {
            StaticVirtualEventWithAccessorsPlaceHolder -= value;
        }
    }

    // NB
    // Wrap event invocations inside a protected virtual method
    // to allow derived classes to override the event invocation behavior
    void RaisetStaticVirtualEvent()
    {
        StaticVirtualEvent?.Invoke(this, new InterfaceEventArgs("Raise interface static virtual event in the interface!"));
    }

    // NB
    // Wrap event invocations inside a protected virtual method
    // to allow derived classes to override the event invocation behavior
    void RaisetImplicitStaticVirtualEventWithAccessors()
    {
        StaticVirtualEventWithAccessorsPlaceHolder?.Invoke(this, new InterfaceEventArgs("Raise interface static virtual event with accessors in the interface!"));
    }
}

interface IGenericOperator<T> where T: IGenericOperator<T>
{
    // NB
    // The parameter of a unary operator must be the containing type, or its type parameter constrained to it.
    // One of the parameters of a binary operator must be the containing type.
    // overloadable unary operators:
    // +  -  !  ~  ++  --  true  false
    // overloadable binary operators:
    // +  -  *  /  %  &  |  ^  <<  >>  ==  !=  >  <  <=  >=

    // CS 11
    // static abstract only in interface
    // interface static abstract operator must be implemented (implicitly) in the implementing type without the override keyword
    // Type arguments implement declared interface
    // The parameter type for ++ or -- operator must be the containing type, or its type parameter constrained to it
    static abstract T operator ++(T t);

    // CS 11
    // static virtual only in interface
    // optional to implement interface static virtual operator (implicitly) in the implementing type, however without the override keyword if implemented 
    static virtual T operator --(T t) => t;
}

class StaticImplementation : IStatic
{
    // mandatory (implicit or explicit) implementation
    // implicit implementation
    public string InstanceProperty { get; set; } = "interface instance property implicitly implemented";
    // Or
    // explicit implementation
    string IStatic.InstanceProperty { get; set; } = "interface instance property explicitly implemented";

    // mandatory (implicit or explicit) implementation
    // implicit implementation
    public string AbstractProperty { get; set; } = "interface abstract property implicitly implemented";
    // Or
    // explicit implementation
    string IStatic.AbstractProperty { get; set; } = "interface abstract property explicitly implemented";

    // optional (implicit or explicit) implementation
    // implicit implementation
    public string VirtualProperty { get; set; } = "interface virtual property implicitly implemented";
    // Or
    // explicit implementation
    string setValue = "interface virtual property explicitly implemented";
    string IStatic.VirtualProperty
    {
        get { return setValue; }
        set { setValue = value; }
    }

    // mandatory (implicit or explicit) implementation
    // implicit implementation
    public void AbstractMethod()
    {
        Console.WriteLine("interface abstract method implicitly implemented");
    }
    // Or
    // explicit implementation
    void IStatic.AbstractMethod()
    {
        Console.WriteLine("interface abstract method explicitly implemented");
    }

    // optional (implicit or explicit) implementation
    // implicit implementation
    public void VirtualMethod()
    {
        Console.WriteLine("interface virtual method implicitly implemented");
    }
    // Or
    // explicit implementation
    void IStatic.VirtualMethod()
    {
        Console.WriteLine("interface virtual method explicitly implemented");
    }


    private int[] indexerArray1D = new int[100];
    private int[,] indexerArray2D = new int[100, 100];
    private int[,,] indexerArray3D = new int[100, 100, 100];

    // mandatory (implicit or explicit) implementation
    // implicit implementation
    public int this[int i] // indexer declaration
    {
        // The array object will throw IndexOutOfRange exception.
        get => indexerArray1D[i];
        set => indexerArray1D[i] = value;
    }
    // Or
    // explicit implementation
    int IStatic.this[int i] // indexer declaration
    {
        // The array object will throw IndexOutOfRange exception.
        get => indexerArray1D[i];
        set => indexerArray1D[i] = value;
    }

    // mandatory (implicit or explicit) implementation
    // implicit implementation
    public int this[int i, int j] // indexer declaration
    {
        // The array object will throw IndexOutOfRange exception.
        get => indexerArray2D[i, j];
        set => indexerArray2D[i, j] = value;
    }
    // Or
    // explicit implementation
    int IStatic.this[int i, int j] // indexer declaration
    {
        // The array object will throw IndexOutOfRange exception.
        get => indexerArray2D[i, j];
        set => indexerArray2D[i, j] = value;
    }

    // optional (implicit or explicit) implementation
    // implicit implementation
    public int this[int i, int j, int k] // indexer declaration
    {
        // The array object will throw IndexOutOfRange exception.
        get => indexerArray3D[i, j, k];
        set => indexerArray3D[i, j, k] = value;
    }
    // Or
    // explicit implementation
    int IStatic.this[int i, int j, int k] // indexer declaration
    {
        // The array object will throw IndexOutOfRange exception.
        get => indexerArray3D[i, j, k];
        set => indexerArray3D[i, j, k] = value;
    }

    public event InterfaceEventHandler? InstanceEventPlaceHolderExplicit;
    private object objectLockInstanceEvent = new object();

    // mandatory (implicit or explicit) implementation
    // mandatory implementation
    public event InterfaceEventHandler? InstanceEvent;
    // Or
    // explicit implementation
    // explicit interface implementation of an event must use event accessor syntax
    event InterfaceEventHandler? IStatic.InstanceEvent
    {
        add
        {
            lock (objectLockInstanceEvent)
            {
                InstanceEventPlaceHolderExplicit += value;
            }
        }
        remove
        {
            lock (objectLockInstanceEvent)
            {
                InstanceEventPlaceHolderExplicit -= value;
            }
        }
    }
    
    // NB
    // Wrap event invocations inside a protected virtual method
    // to allow derived classes to override the event invocation behavior
    public void RaiseImplicitInstanceeEvent()
    {
        InstanceEvent?.Invoke(this, new InterfaceEventArgs("Raise implicit interface instance event in the implementing type!"));
    }

    // NB
    // Wrap event invocations inside a protected virtual method
    // to allow derived classes to override the event invocation behavior
    public void RaiseExplicitInstanceeEvent()
    {
        InstanceEventPlaceHolderExplicit?.Invoke(this, new InterfaceEventArgs("Raise explicit interface instance event in the implementing type!"));
    }
}

class StaticGenericImplementation : IStaticGeneric<StaticGenericImplementation>
{
    // CS 11
    // mandatory (implicit or explicit) implementation
    // implicit implementation
    public static string StaticAbstractProperty { get; set; } = "interface static abstract property implicitly implemented";
    // Or
    // explicit implementation
    static string IStaticGeneric<StaticGenericImplementation>.StaticAbstractProperty { get; set; } = "interface static abstract property explicitly implemented";

    // CS 11
    // mandatory (implicit or explicit) implementation
    // implicit implementation
    public static void StaticAbstractMethod()
    {
        Console.WriteLine("interface static abstract implicitly method implemented");
    }
    // Or
    // explicit implementation
    static void IStaticGeneric<StaticGenericImplementation>.StaticAbstractMethod()
    {
        Console.WriteLine("interface static abstract method explicitly implemented");
    }

    // CS 11
    // optional (implicit or explicit) implementation
    // implicit implementation
    public static string StaticVirtualProperty { get; set; } = "interface static virtual property implicitly implemented";
    // Or
    // explicit implementation
    static string IStaticGeneric<StaticGenericImplementation>.StaticVirtualProperty { get; set; } = "interface static virtual property explicitlyimplemented";

    // CS 11
    // optional (implicit or explicit) implementation
    // implicit implementation
    public static void StaticVirtualMethod()
    {
        Console.WriteLine("interface static virtual method implicitly implemented");
    }
    // Or
    // explicit implementation
    static void IStaticGeneric<StaticGenericImplementation>.StaticVirtualMethod()
    {
        Console.WriteLine("interface static virtual method explicitly implemented");
    }

    public static event InterfaceEventHandler? StaticAbstractEventPlaceHolderExplicit;
    private static object objectLockStaticAbstractEvent = new object();

    // CS 11
    // mandatory (implicit or explicit) implementation
    // implicit implementation
    public static event InterfaceEventHandler? StaticAbstractEvent;
    // Or
    // explicit implementation
    // explicit interface implementation of an event must use event accessor syntax
    static event InterfaceEventHandler? IStaticGeneric<StaticGenericImplementation>.StaticAbstractEvent
    {
        add
        {
            lock (objectLockStaticAbstractEvent)
            {
                StaticAbstractEventPlaceHolderExplicit += value;
            }
        }
        remove
        {
            lock (objectLockStaticAbstractEvent)
            {
                StaticAbstractEventPlaceHolderExplicit -= value;
            }
        }
    }

    // NB
    // Wrap event invocations inside a protected virtual method
    // to allow derived classes to override the event invocation behavior
    public void RaisetImplicitStaticAbstractEvent()
    {
        StaticAbstractEvent?.Invoke(this, new InterfaceEventArgs("Raise implicit interface static abstract event in the implementing type!!"));
    }

    // NB
    // Wrap event invocations inside a protected virtual method
    // to allow derived classes to override the event invocation behavior
    public void RaisetExplicitStaticAbstractEvent()
    {
        StaticAbstractEventPlaceHolderExplicit?.Invoke(this, new InterfaceEventArgs("Raise explicit interface static abstract event in the implementing type!!"));
    }

    public static event InterfaceEventHandler? StaticVirtualEventPlaceHolderExplicit;
    private static object objectLockStaticVirtualEvent = new object();

    // CS 11
    // optional (implicit or explicit) implementation
    // implicit implementation
    public static event InterfaceEventHandler? StaticVirtualEvent;
    // Or
    // explicit implementation
    // explicit interface implementation of an event must use event accessor syntax
    static event InterfaceEventHandler? IStaticGeneric<StaticGenericImplementation>.StaticVirtualEvent
    {
        add
        {
            lock (objectLockStaticVirtualEvent)
            {
                StaticVirtualEventPlaceHolderExplicit += value;
            }
        }
        remove
        {
            lock (objectLockStaticVirtualEvent)
            {
                StaticVirtualEventPlaceHolderExplicit -= value;
            }
        }
    }

    // NB
    // Wrap event invocations inside a protected virtual method
    // to allow derived classes to override the event invocation behavior
    public void RaisetImplicitStaticVirtualEvent()
    {
        StaticVirtualEvent?.Invoke(this, new InterfaceEventArgs("Raise implicit interface static virtual event in the implementing type!!"));
    }

    // NB
    // Wrap event invocations inside a protected virtual method
    // to allow derived classes to override the event invocation behavior
    public void RaisetExplicitStaticVirtualEvent() 
    {
        StaticVirtualEventPlaceHolderExplicit?.Invoke(this, new InterfaceEventArgs("Raise explicit interface static virtual event in the implementing type!!"));
    }

    private event InterfaceEventHandler? StaticVirtualEventWithAccessorsPlaceHolderImplementation;
    private static object objectLockStaticVirtualEventWithAccessors = new object();

    public static event InterfaceEventHandler? StaticVirtualEventWithAccessorsPlaceHolderImplementationExplicit;
    private static object objectLockStaticVirtualEventWithAccessorsExplicit = new object();

    // CS 11
    // optional (implicit or explicit) implementation
    // implicit implementation
    public event InterfaceEventHandler? StaticVirtualEventWithAccessors
    {
        add
        {
            lock (objectLockStaticVirtualEventWithAccessors)
            {
                StaticVirtualEventWithAccessorsPlaceHolderImplementation += value;
            }
        }
        remove
        {
            lock (objectLockStaticVirtualEventWithAccessors)
            {
                StaticVirtualEventWithAccessorsPlaceHolderImplementation -= value;
            }
        }
    }
    // Or
    // explicit implementation
    // explicit interface implementation of an event must use event accessor syntax
    static event InterfaceEventHandler? IStaticGeneric<StaticGenericImplementation>.StaticVirtualEventWithAccessors
    {
        add
        {
            lock (objectLockStaticVirtualEventWithAccessorsExplicit)
            {
                StaticVirtualEventWithAccessorsPlaceHolderImplementationExplicit += value;
            }
        }
        remove
        {
            lock (objectLockStaticVirtualEventWithAccessorsExplicit)
            {
                StaticVirtualEventWithAccessorsPlaceHolderImplementationExplicit -= value;
            }
        }
    }

    // NB
    // Wrap event invocations inside a protected virtual method
    // to allow derived classes to override the event invocation behavior
    public void RaisetImplicitStaticVirtualEventWithAccessors()
    {
        StaticVirtualEventWithAccessorsPlaceHolderImplementation?.Invoke(this, new InterfaceEventArgs("Raise implicit interface static virtual event with accessors in the implementing type!"));
    }

    // NB
    // Wrap event invocations inside a protected virtual method
    // to allow derived classes to override the event invocation behavior
    public void RaisetExplicitStaticVirtualEventWithAccessors()
    {
        StaticVirtualEventWithAccessorsPlaceHolderImplementationExplicit?.Invoke(this, new InterfaceEventArgs("Raise explicit interface static virtual event with accessors in the implementing type!"));
    }
}

// CS 11
// static abstract operator receiver type should be a valid record/struct type
// ref structs cannot implement interfaces and may not be used as a type argument
// struct OperatorImplementation : IGenericOperator<OperatorImplementation>
record OperatorImplementation : IGenericOperator<OperatorImplementation>
{
    int number = 0;
    int sixtyFive = 65;
    int hundredAndTwentyTwo = 122;

    // For struct // A 'struct' with field initializers must include an explicitly declared constructor.
    // public OperatorImplementation() { }

    // CS 11
    // mandatory implicit implementation
    public static OperatorImplementation operator ++(OperatorImplementation implementationOperator)
        => implementationOperator with
        {
            sixtyFive = implementationOperator.sixtyFive + 1,
            number = implementationOperator.sixtyFive
        };

    // CS 11
    // optional implicit implementation
    public static OperatorImplementation operator --(OperatorImplementation implementationOperator)
        => implementationOperator with
        {
            hundredAndTwentyTwo = implementationOperator.hundredAndTwentyTwo - 1,
            number = implementationOperator.hundredAndTwentyTwo
        };

    public override string ToString() => ((char)number).ToString();
}
/******************************************************************************/


// class, interface, struct, readonly struct, ref struct, readonly ref struct, record, positional record, record struct, readonly record struct
/******************************************************************************/
// Reference Type 
class C : I
{
    static C() { }
    public C() { }
    ~C() { }
}

// Reference Type 
interface I
{
    static I() { }
}

// Value Type
// struct can implement interface only
struct S : I
{
    static S() { }
    public S() { }
}

// CS 7.2 // Value Type
readonly struct ReadOnlyStructure : I
{
    static ReadOnlyStructure() { }
    public ReadOnlyStructure() { }
}
// ref structs cannot implement interface 
ref struct RefStructure
{
    static RefStructure() { }
    public RefStructure() { }
}
readonly ref struct ReadOnlyRefStructure
{
    static ReadOnlyRefStructure() { }
    public ReadOnlyRefStructure() { }
}

// CS 9 // Reference Type 
// Can inherit object or another record only and implement interface
// Cannot inherit class and cannot be base for class
record BaseRecord : I
{
    static BaseRecord() { }
    public BaseRecord() { }
    ~BaseRecord() { }
}
record DerivedRecord : BaseRecord, I
{
    static DerivedRecord() { }
    public DerivedRecord() { }
    ~DerivedRecord() { }
}
record ObjectRecord : object, I
{
    static ObjectRecord() { }
    public ObjectRecord() { }
    ~ObjectRecord() { }
}
// Positional records
// The primary constructor parameters to a record are referred to as positional parameters.
record BasePositionalRecord(string Alpha, string Beta) : I
{
    static BasePositionalRecord() { }
    public BasePositionalRecord() : this(string.Empty, string.Empty) { }
    ~BasePositionalRecord() { }
}
record DerivedPositionalRecord(string Alpha, string Beta, string Gamma) : BasePositionalRecord(Alpha, Beta), I
{
    static DerivedPositionalRecord() { }
    public DerivedPositionalRecord() : this(string.Empty, string.Empty, string.Empty) { }
    ~DerivedPositionalRecord() { }
}
record ObjectPositionalRecord(string Epsilon, string Zeta) : object, I
{
    static ObjectPositionalRecord() { }
    public ObjectPositionalRecord() : this(string.Empty, string.Empty) { }
    ~ObjectPositionalRecord() { }
}
// Positional record extending record
record ExtendedPositionalRecord(string Alpha, string Beta, string Gamma) : BaseRecord, I
{
    static ExtendedPositionalRecord() { }
    public ExtendedPositionalRecord() : this(string.Empty, string.Empty, string.Empty) { }
    ~ExtendedPositionalRecord() { }
}
// Record extending positional record 
record ExtentedRecord : BasePositionalRecord, I
{
    static ExtentedRecord() { }
    public ExtentedRecord() : this(string.Empty, string.Empty, string.Empty) { }
    public ExtentedRecord(string Alpha, string Beta, string Gamma) : base(Alpha, Beta) { }
    ~ExtentedRecord() { }
}

// CS 10 // Value Type
record struct RecordStructure : I
{
    static RecordStructure() { }
    public RecordStructure() { }
}
readonly record struct ReadOnlyRecordStructure : I
{
    static ReadOnlyRecordStructure() { }
    public ReadOnlyRecordStructure() { }
}
/******************************************************************************/