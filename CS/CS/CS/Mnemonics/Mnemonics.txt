/******************************************************************************/

// CS 1 // Subject to updates in higher versions of CS

/******************************************************************************/

Namespace (essentially class/struct) elements (class, interface, delegate, struct, enum) cannot be explicitly declared as private, protected, or protected internal

REFERENCE TYPES:

class:
// (Can be sealed, Can be static, Can be abstract)
// (Can inherit object, Can implement interface)
// <can be generic>


data members 
1. consts

2. static fields (including static volatile and static readonly) 

3. instance fields (including instance volatile and instance readonly) 

// Variable AND const can be LOCAL (without access specifiers and member modifiers) [inside static/instance method] (ASSIGNMENT AT DECLARATION MUST)


function members:
1. methods (instance/static) <can be generic>

*ONLY instance methods can be [abstract ONLY in abstract class & MUST be implemented] & can be 'sealed' when overridden
[* although not abstract in interface, instance methods in interface can be mapped onto abstract 
in the implementing (MUST & only public implementation is possible) abstract class]


# ONLY instance methods can be [virtual in class/abstract class] & can be 'sealed' when overridden
[# although not virtual in interface, instance methods in interface can be mapped onto virtual 
in the implementing (only public implementation is possible) class/abstract class]


2. constructors (instance/static(which must be parameterless))


3. destructors


4. indexers (instance, can't return void) (indexers cannot be static as 'this' cannot be used with static) :

* indexers (can only be instance) [can only be accessor based] can be [abstract ONLY in abstract class & MUST be implemented] & can be 'sealed' when overridden
[* although not abstract in interface, indexers (can only be instance) [can only be accessor based] in interface can be mapped onto abstract 
in the implementing (MUST & only public implementation is possible) abstract class]


# indexers (instance) [can only be accessor based] can be [virtual in class/abstract class] & can be 'sealed' when overridden
[# although not virtual in interface, indexers (can only be instance) [can only be accessor based] in interface can be mapped onto virtual 
in the implementing (only public implementation is possible) class/abstract class]


can be overloaded


need not require an underlying array


can be read-only without set accessors


can be multidimensional


5. properties (instance/static, can't return void)

* ONLY instance properties [can only be accessor based] can be [abstract ONLY in abstract class & MUST be implemented] & can be 'sealed' when overridden
[* although not abstract in interface, instance properties [can only be accessor based] in interface can be mapped onto abstract 
in the implementing (MUST & only public implementation is possible) class/abstract class]


# ONLY instance properties [can only be accessor based] can be [virtual in class/abstract class] & can be 'sealed' when overridden
[# although not virtual in interface, instance properties [can only be accessor based] in interface can be mapped onto virtual 
in the implementing (only public implementation is possible) class/abstract class]

static property can access [const as read-only static property] DIRECTLY  

static property can access ONLY [static fields] including [static volatile] AND [static readonly as read-only static property] DIRECTLY 

static property can access [instance fields] including [instance volatile] AND [instance readonly as read-only static property] 
USING mc CREATED INSIDE class as: static MyClass mc = new MyClass(); 

instance property can access [const as read-only instance property] DIRECTLY  

instance property can access [static/instance fields] including [static/instance volatile] AND [static/instance readonly as read-only static property] DIRECTLY 

static property [except read-only] can be assigned in static constructor 

static property [except read-only] &
**[EXCEPT that accessing instance field (including instance volatile) [throws System.NullReferenceException]] *{NOT IN struct}* 
can be assigned in instance constructor 

instance property [except read-only] can be assigned in static constructor 
USING: mc CREATED INSIDE class as: static MyClass mc = new MyClass(); 
[NOT USEFUL for instance property accessing instance fields (including instance volatile)]
[NOT USEFUL if simultaneously assigned in instance constructor]

instance property [except read-only] can be assigned in instance constructor


cannot be passed as ref/out parameters to methods

cannot be overloaded

two (or more) different properties [even if one is static and the other is instance] can access the same variable although unusual

get operation should be nonintrusive although not enforced by the compiler


6. events (instance/static):

* ONLY instance events [except accessor based] can be [abstract ONLY in abstract class & MUST be implemented] & can be 'sealed' when overridden
[* although not abstract in interface, instance events [except accessor based] in interface can be mapped onto abstract 
in the implementing (MUST & only public implementation is possible) abstract class]


# ONLY instance events [including accessor based] can be [virtual in class/abstract class] & can be 'sealed' when overridden
[# although not virtual in interface, instance events [including accessor based] in interface can be mapped onto virtual 
in the implementing (only public implementation is possible) class/abstract class]


7. operators (static)



[The members of a class are the members declared in the class and the members inherited from the base class (except for the class object, which has no base class). 
The members inherited from the base class include the constants, fields, methods, properties, events, indexers, operators, 
and types of the base class, but not the instance constructors, destructors, and static constructors of the base class. 
Base class members are inherited without regard to their accessibility.]




interface:
// (CANNOT be sealed, CANNOT be static, CANNOT be abstract)
// (CANNOT inherit object, Can inherit another interface)
// <can be generic [and the implementing abstract class/class/struct MUST be generic EXCEPT when implementing built-in IComparable interface]>


(no member can be static)
(no member can have explicit access modifier)
(member cannot be abstract, virtual (override, new and cannot use 'base'))

[all the members must be implemented by class/abstract class/struct, no partial implementation]

[although not abstract in interface, instance methods, indexers (only instance), instance properties, instance events [except accessor based] can be mapped onto abstract 
in the implementing (MUST & only public implementation is possible) abstract class]

[although not virtual in interface, instance methods, indexers (only instance), instance properties, instance events can be mapped onto virtual 
in the implementing (only public implementation is possible) class/abstract class]


NO data members

function members:

NO constructors/destructors/operator methods

1. instance methods (only stubs [return type, method name, parameter(if any)] with semicolon (essentially abstract)) 
<can be generic in generic/non-generic interface>

2. indexers (instance, can't return void)  (get; set; (without body))

can be overloaded

can be multidimensional

3. instance properties (instance, can't return void)  (get; set; (without body))

instance properties in interface, public implementation by class/struct:

instance property can access [const as read-only instance property] DIRECTLY  

instance property can access [static/instance fields] including [static/instance volatile] AND [static/instance readonly as read-only static property] DIRECTLY 

instance property [except read-only] can be assigned in static constructor 
USING: [mc/ms] CREATED INSIDE class/struct as: [static MyClass mc = new MyClass();]/[static MyStruct ms = new MyStruct()]
[NOT USEFUL for instance property accessing instance fields (including instance volatile)]
[NOT USEFUL if simultaneously assigned in instance constructor]

instance property [except read-only] can be assigned in instance constructor

two (or more) different properties [ONLY instance properties in interface] can access the same variable although unusual


instance properties in interface, private and explicit implementation by class/struct:

instance property can access [const as read-only instance property] DIRECTLY  

instance property can access [static/instance fields] including [static/instance volatile] AND [static/instance readonly as read-only static property] DIRECTLY 

instance property [except read-only] can be assigned in static constructor 
USING: [mc/ms] CREATED INSIDE class/struct as: [static MyClass mc = new MyClass();]/[static MyStruct ms = new MyStruct();]
**{AND USING: mi CREATED INSIDE static constructor as: MyInterface mi = (MyInterface)mc;}**
[NOT USEFUL for instance property accessing instance fields (including instance volatile)]
[NOT USEFUL if simultaneously assigned in instance constructor]

instance property [except read-only] can be assigned in instance constructor
*{AND USING: mi CREATED INSIDE static constructor as: MyInterface mi = this;}*

two (or more) different properties [ONLY instance properties in interface] can access the same variable although unusual



cannot be passed as ref/out parameters to methods

cannot be overloaded

get operation should be nonintrusive although not enforced by the compiler


4. instance events (implementing class/struct must supply the event)

Note:

1. interface can inherit from another interface (BUT interface cannot be 'sealed')

2. An interface can itself inherit from multiple and multilevel interfaces.

3. You can create interface reference variable

4. You can specify derived interface member with new if it hides one defined by base interface

5. any number of classes/abstract classes/structs can implement an interface (along with their own)

6. one class/abstract class/struct can implement any number of interfaces (in a comma-separated list (base class if present must come first))

7. can create explicit interface (member) implementation, 
which MUST BE CALLED THROUGH an interface reference (to the implementing class' object TYPECAST USING THE INTERFACE)
or
which MUST BE CALLED THROUGH an interface reference (to the implementing struct's object TYPECAST USING THE INTERFACE)

8. cannot create partial implementation of interface

9. any non-abstract type inheriting the interface must implement all its members
(abstract type inheriting the interface must either implement or map onto abstract)

10. interface can do without its members


Note:
while declaring method(member) in interface:

1. return type and signature must match the return type and signature of the implementing method(member)

2. declared using only their return type and signature

3. no explicit access specifier allowed 
(implicitly public, so the implementing method must also be public except during private(default) and explicit implementation)

[The members of an interface are the members declared in the interface and in all base interfaces of the interface 
The members in class object are not, strictly speaking, members of any interface 
However, the members in class object are available via member lookup in any interface type and the members inherited from the class object]





array: (A namespace cannot contain array directly but class/struct(at namespace level) can contain array directly)
[The members of an array are the members inherited from the class (But NOT EXTEND) System.Array]




delegate:
// (CANNOT be sealed, CANNOT be static, CANNOT be abstract)
// (CANNOT inherit object, CANNOT implement interface)
// <can be generic>


[The members of a delegate are the members inherited from the class (But NOT EXTEND) System.Delegate]

{delegate can be used inside abstract class/class/struct. Although not as a member, can have access the modifiers as that of a member}




object: (should only be inherited and extended only to class)
[The members of object correspond directly to the members of the class types they alias
The members of object are the members of the System.Object class]



string: (A namespace cannot contain string directly but class/struct(at namespace level) can contain string directly)
[The members of string correspond directly to the members of the class types they alias. 
The members of string are the members of the (But NOT EXTEND) System.String class]




VALUE TYPES:

struct:
// (CANNOT be sealed, CANNOT be static, CANNOT be abstract)
// (CANNOT inherit object, Can implement interface)
// <can be generic>


(member cannot be abstract, virtual (override, new and cannot use 'base'), protected or protected internal)

data members (fields):
1. consts

2. static fields (including static volatile and static readonly)

3. instance fields (including instance volatile and instance readonly) 
[cannot have instance field (including instance volatile and instance readonly) initializers in structs]

// Variable AND const can be LOCAL (without access specifiers and member modifiers) [inside static/instance method] (ASSIGNMENT AT DECLARATION MUST)


function members:

1. methods (instance/static) <can be generic>

2. constructors (instance/static (which must be parameterless)) (BUT NOT EXPLICIT parameterless instance constructor, because it is automatically defined (implicit)) 
(However can have EXPLICIT parameterless static constructor(But not parameterized static constructor))
*Note: struct cannot be static

[NO DESTRUCTORS]

3. indexers (instance, can't return void) 
[can be overloaded 
can be multidimensional]

4. properties (instance/static, can't return void) 

static property can access [const as read-only static property] DIRECTLY  

static property can access ONLY [static fields] including [static volatile] AND [static readonly as read-only static property] DIRECTLY 

static property can access [instance fields] including [instance volatile] AND [instance readonly as read-only static property] 
USING ms CREATED INSIDE struct as: static MyStruct mc = new MyStruct(); 

instance property can access [const as read-only instance property] DIRECTLY  

instance property can access [static/instance fields] including [static/instance volatile] AND [static/instance readonly as read-only static property] DIRECTLY 

static property [except read-only] can be assigned in static constructor 

static property [except read-only] &
**[INCLUDING that accessing instance field (including instance volatile)] *{NOT IN class}* 
can be assigned in instance constructor 

instance property [except read-only] can be assigned in static constructor 
USING: ms CREATED INSIDE struct as: static MyStruct ms = new MyStruct(); 
[NOT USEFUL for instance property accessing instance fields (including instance volatile)]
[NOT USEFUL if simultaneously assigned in instance constructor]

instance property [except read-only] can be assigned in instance constructor


cannot be passed as ref/out parameters to methods

cannot be overloaded

two (or more) different properties [even if one is static and the other is instance] can access the same variable although unusual

get operation should be nonintrusive although not enforced by the compiler


5. events (instance/static)

6. operators (static)

Note:

1. can inherit only object (NOT EXTEND object unlike abstract class/static class/class), cannot be inherited

2. structure object can be created using new but not required
(when new is used, the specified constructor is called, when new is not used, 
the object is still created but not initialized, need to perform initialization manually )
 
struct
3. cannot contain EXPLICIT parameterless instance constructors but can have EXPLICIT parameterless static constructors
4. cannot have instance (including instance volatile and instance readonly) field initializers in structs
5. Hence, when parameterized instance constructor is used in struct 
instance fields (including instance volatile and instance readonly) must be fully assigned before control leaves
parameterized instance constructor OR : this()
    
6. {event} in [struct]:
add:
1. assign the event handler method without parenthesis (using class for static and using object for instance) to the delegate instance
2. add the assigned delegate instance to the event list
remove:
1. remove the assigned delegate instance 


[The members of a struct are the members declared in the struct 
and the members inherited from the struct's direct base class System.ValueType and the indirect base class object.
(But NOT EXTEND System.ValueType, object unlike class)
 
The members of a simple type correspond directly to the members of the struct type aliased by the simple type.
Example: The members of sbyte are the members of the (But NOT EXTEND) System.SByte struct.]




enum:
// (CANNOT be sealed, CANNOT be static, CANNOT be abstract)
// (CANNOT inherit object, CANNOT implement interface)
// <CANNOT be generic>


CAN extend only sbyte, byte, short, ushort, int, uint, long, or ulong [integral types other than char]
[The members of an enumeration are the constants declared in the enumeration 
and the members inherited from the enumeration's direct base class System.Enum 
and the indirect base classes System.ValueType 
and object. (But CANNOT EXTEND System.Enum, System.ValueType, object)]

{enum can be used inside abstract class/class/struct, in which case can have the access modifiers as that of a member}

/******************************************************************************/

// abstract class:
// (CANNOT be sealed, CANNOT be static)
// (can inherit object, can implement interface)
// <can be generic>


data members 
1. consts

2. static fields (including static volatile and static readonly) 

3. instance fields (including instance volatile and instance readonly) 

// Variable AND const can be LOCAL (without access specifiers and member modifiers) [inside static/instance method] (ASSIGNMENT AT DECLARATION MUST)


// members of a class are also members of an abstract class

// abstract class have const, readonly [which can be assigned ONLY in BaseClass constructor via DerivedClass constructor using base()] 

// abstract class can have constructors(instance/static (which must be parameterless)) and destructor
 
// abstract class constructors can be overloaded using derived class constructor [using base()]

// method/indexer/properties/events[except accessor based] can be abstract and that too only in abstract class  

// method/indexer/properties/events[including accessor based] can be virtual and can be in abstract class

// abstract class can do without abstract members (method/indexer/properties/events[except accessor based])

// abstract method has only stubs with semicolon, can have parameter, but no body 


// abstract method must be implemented (overridden and can be 'sealed') in all the 1st level derived non-abstract classes
// NOT A MUST in the 1st level derived abstract classes (if any)
// BUT MUST in the 1st level derived abstract classes' next level derived non-abstract classes (if any)
// IF the next level derived classes are abstract then MUST in the further next level derived non-abstract classes (if any) and so on


// abstract method cannot be static, as static cannot be used with abstract, virtual or override

// abstract class cannot be instantiated but you can have reference variable of abstract class

// abstract class can have concrete methods (both instance and static)

// abstract class can have virtual methods 

// abstract class can inherit from abstract or non-abstract class (including multilevel & excluding multiple)

// non-abstract class can be inherited from an abstract class (including multilevel & excluding multiple)


// instance methods in abstract class Can be be invoked using 
// 1. [BASE CLASS REFERENCE that refers DERIVED CLASS OBJECT]
// 2. [DERIVED CLASS OBJECT] 

// static methods in abstract class can access instance variables by
// 1. USING BASE CLASS REFERENCE PASSED IN PARAMETER that allows [BASE CLASS REFERENCE that refers DERIVED CLASS OBJECT] PASSED IN ARGUMENT from Main()
// 2. USING BASE CLASS REFERENCE PASSED IN PARAMETER that allows [DERIVED CLASS OBJECT] PASSED IN ARGUMENT from Main()



// abstract, virtual CANNOT be private (default) in base class
// and when overridden in derived class, the access modifier, return type and parameter(if any) should be same

// abstract, virtual CAN be protected in base class BUT:
// accessed ONLY INSIDE *derived class (or derived from it) 
// accessed ONLY INSIDE *derived classes[including further derived] of the same/different assembly
// [#especially for instance member] via a qualifier of type derived class [$via qualifier of further derived in further derived] 
// [*derived class should NOT be thought of Main()'s class]
// [Note: class should be public for accessing from derived class in different assembly]


// #Note: to call virtualMethod() that is in abstract BaseClass
// use 'base' inside an instance method [Also: parameter for the method to receive and pass to the argument (if any) inside the method]  
// or inside the overridden method of virtual (if overridden) or inside the overridden method of abstract (if any)
// using dot and argument for the parameter(if any) 

// *Note: 'base' cannot be used in a static method 

// @Note: 'base' ONLY for new (instance method that is in BaseClass) AND virtual (method that is in BaseClass) 
// BUT NOT for abstract method (method that is in BaseClass) 

// $Note:  use BaseClass for new (static method that is in BaseClass) 
// inside static or instance method [Also: parameter for the method to receive and pass to the argument (if any) inside the method]
// using dot and argument for the parameter (if any)




// static class:
// (CANNOT be sealed, CANNOT be abstract)
// (can inherit object, CANNOT implement interface)
// <can be generic>


data members 
1. consts

2. static fields (including static volatile and static readonly) 

// Variable AND const can be LOCAL (without access specifiers and member modifiers) [ONLY inside static method in static class] (ASSIGNMENT AT DECLARATION MUST)


// static class can contain only consts, static variables, static methods, static properties, static events

// static class can contain only static constructor

// static class cannot contain destructor

// static class cannot have protected or protected internal members but can be protected or protected internal in a class/struct(at namespace level)

// static class cannot be derived 

// static class can EXTEND (and inherit only static members) only from object

// static class can use static object (built-in)

/******************************************************************************/


/******************************************************************************/

1. 
// static members are associated with class




2. 
// instance members are associated with objects 




3.
/*

class member accessibility:

private(default): 
1. accessible only in the class in which it is declared

< 

protected: 
(private(default): 1) and
2. accessible ONLY INSIDE *derived classes[including further derived] of the same/different/friend assembly
[#especially for instance member] via a qualifier of type derived class [$via qualifier of further derived in further derived] 
[Note: The class where it is protected should be public for accessing from derived class in different assembly]
[But the class where it is protected can be internal for accessing from derived class in friend assembly]

<

internal:
(internal: 1, 2) and
3. accessible in all the classes/derived classes of the same assembly and friend assembly

<

protected internal:
(protected internal: 1, 2, 3)
[Note: The class where it is protected internal should be public for accessing from derived class in different assembly]
[But the class where it is protected internal can be internal for accessing from derived class in friend assembly]




public:
accessible in all the classes/derived classes, of the same/different/friend assembly
[Note: The class where it is public should be public for accessing from different assembly]
[But the class where it is public can be internal for accessing from friend assembly]

*/




4.
/*

struct member accessibility:

private(default): 
1. accessed only in the struct in which it is declared

<

internal:
(internal: 1) and
2. accessed in all the structs of the same assembly

<

public:
accessed in all the structs of the same/different assembly

*/





5. 
// 'new' must precede the member type and name // new public int number // public new int number;

// 'new' must precede the method return type // new public void myMethod() // public new void myMethod()




6. 
// 'static' must precede the member type and name eg. public static int number;




7. 
// 'this' is used for instance variables; 

// Also: 'this' is used 'for one constructor to invoke another; for constructor with implied default arguments, which are not explicitly specified

// Also: 'this' is used for indexers

// this() can be used in struct constructor overloading

// static cannot be used with 'this'


// *Note: 'this' cannot be used in a static method 





8. 
// static cannot be used with override, virtual, or abstract (but static can be used with new)




9.
// #Note: to call virtualMethod() that is in abstract BaseClass
// use "base.virtualMethod()" inside an instance method [Also: parameter for the method to receive and pass to the argument (if any) inside the method]  
// or use "base.virtualMethod()" inside the overridden method of virtual (if overridden) 
// or use "base.virtualMethod()" inside the overridden method of abstract (if any)
// using dot and argument for the parameter(if any) 

// *Note: 'base' cannot be used in a static method 

// @Note: 'base' ONLY for new (instance method that is in BaseClass) AND virtual (method that is in BaseClass) 
// BUT NOT for abstract method (method that is in BaseClass) 

// $Note:  use BaseClass for new (static method that is in BaseClass) 
// inside static or instance method [Also: parameter for the method to receive and pass to the argument (if any) inside the method]
// using dot and argument for the parameter (if any)




10.
// 'base' can ONLY be used with new (non-static and non-private) and that too in inheritance

// abstract, virtual CANNOT be private (default) in base class
// and when overridden in derived class, the access modifier, return type and parameter(if any) should be same

// abstract, virtual CAN be protected in base class BUT:
// accessed ONLY INSIDE *derived class (or derived from it) 
// accessed ONLY INSIDE *derived classes[including further derived] of the same/different assembly
// [#especially for instance member] via a qualifier of type derived class [$via qualifier of further derived in further derived] 
// [*derived class should NOT be thought of Main()'s class]
// [Note: class should be public for accessing from derived class in different assembly]




11.
abstract - override:

access modifiers should be same
[Note: NO member modifier 'static']
[override cannot be marked as new or virtual or abstract]
return types should be same
parameters should be same

Note:
'base' CANNOT be used with 'abstract' abstractMethod()
'sealed' can be used only with override, talking about methods
'sealed' means cannot be further overridden in a further derived class
[But abstractMethod() can be used with 'new' in a derived class or a further derived class 
and that means "hiding" 
and that means access modifier, member modifier['static'] and return type can be changed
(and parameter can be changed which means it an entirely different method and does not mean "hiding")]


virtual - override:
access modifiers should be same
[Note: No member modifier 'static']
[override cannot be marked as new or virtual or abstract]
return types should be same
parameters should be same

Note:
'base.' CAN be used with 'virtual' virtualMethod()
'sealed' can be used only with override, talking about methods
'sealed' means cannot be further overridden in a further derived class
[But abstractMethod() can be used with 'new' in a derived class or a further derived class 
and that means "hiding" 
and that means access modifier, member modifier['static'] and return type can be changed
(and parameter can be changed which means it an entirely different method and does not mean "hiding")]


new (used when hiding was intended) in inheritance:
access modifiers, [ALSO member modifier 'static'], return types CAN BE DIFFERENT
BUT PARAMETERS SHOULD BE SAME
[In case parameters are different, it will be an entirely different method 
and hiding WON'T be intended]





12. 
// Dynamic Polymorphism // No wonder static methods are NOT allowed // Runtime Polymorphism // Method Overriding  
// Method Overriding: Capability of a DERIVED CLASS to override the characteristics of the parent class. 
// Provides different implementation of an inherited member (Method) in the DERIVED CLASS
// Always create reference variable
access specifiers, [NO member modifier 'static'], return types, parameters SHOULD BE SAME




13. 
// Static Polymorphism // static methods are ALLOWED// Compile time Polymorphism // Method Overloading
// Method Overloading: Two or more methods within the same class can share the same name, as long as their parameter declarations are different 
// Within the same class and Nothing to do with inheritance unlike Overriding
access modifiers, [ALSO member modifier 'static'], return types CAN BE DIFFERENT
PARAMETER number, type and order SHOULD BE DIFFERENT




14.
// instance [methods/indexers/properties/events]  (only when override) can be sealed, 
// so as to prevent further overriding (further different implementation) in a further derived class
// [BUT can be called using 'base' in an instance method in a further derived class, and that instance method can be called from Main() method] 


// You can call base class instance fields (including instance volatile and instance readonly) and instance [methods/indexers/properties/events] 
// in a derived class instance method using 'base', and then call the instance method from Main()


// [Only assignment, call, increment, decrement, and new object expressions can be used as a statement]




15.
// Constructor Overloading:
// ?Note: parameterless constructor [NEEDED if there is constructor overloading AND parameterless constructor call] 

// Method Overloading:
// ?Note: parameterless Method [NEEDED if there is method overloading AND parameterless method call] 




16.
// 1. base() corresponds parameterless BaseClass constructor

// 2. explicit base() NEED NOT have the corresponding explicit parameterless BaseClass constructor

// 3. 'parameterized base(<parameter*>)' MUST have the corresponding parameterized BaseClass constructor

// 4. Hence 'parameterized base(<parameter*>)' assigns BaseClass variables [even private (default)]


// 5. parameterless constructor [NEEDED if there is constructor overloading AND parameterless constructor call] 
// 6. parameterless constructor [NEEDED if there is BaseClass constructor overloading AND DerivedClass constructor overloading] BUT
//    7. parameterless constructor [NOT NEEDED ONLY if 'parameterized base(<parameter*>)' extends 
//       EVERY DerivedClass parameterized constructor AND if there is NO explicit DerivedClass parameterless constructor] THEREFORE
//       8. parameterless constructor [NEEDED if 'parameterized base(<parameter*>)' extends 
//          EVERY DerivedClass parameterized constructor BUT if there is EXPLICIT DerivedClass parameterless constructor]
//       9. parameterless constructor [NEEDED if 'parameterless base()' OR NOTHING extends EVERY DerivedClass parameterized constructor 
//          EVEN if there is NO EXPLICIT DerivedClass parameterless constructor]
// [EXPLICIT DerivedClass parameterless constructor may be prompted by DerivedClass constructor overloading AND 
//  DerivedClass parameterless constructor call, OR
//  if there is FurtherDerivedClass AND DerivedClass parameterless constructor call and so on] 
// 10. Note: parameter* is any variable(s) from the extended DerivedClass parameterized constructor's signature


// [INHERITANCE: CANNOT Call PROTECTED INSTANCE FROM DERIVED via a qualifier of type 'BaseClass']




17. 
/*

static variable can be used in instance method*
1. and assigned value from OUTSIDE the method USING CONSTRUCTOR CALL in Main() in the same or different class
2. and assigned value from OUTSIDE the method USING CLASS in Main() in the same, or different class in which case it should be public
3. and assigned value from OUTSIDE the method USING METHOD CALL in Main() in the same or different class
4. and assigned value INSIDE THE METHOD DIRECTLY

*static variable can be used in instance method [in different class] ONLY by USING CLASS and should be PUBLIC



static variable can be used in static method*
1. and assigned value from OUTSIDE the method USING CONSTRUCTOR CALL in Main() in the same or different class
2. and assigned value from OUTSIDE the method USING CLASS in Main() in the same, or different class in which case it should be public
3. and assigned value from OUTSIDE the method USING METHOD CALL in Main() in the same or different class
4. and assigned value INSIDE THE METHOD DIRECTLY

*static variable can be used in static method [in different class] ONLY by USING CLASS and should be PUBLIC



instance variable can be used in instance method*
1. and assigned value from OUTSIDE the method USING CONSTRUCTOR CALL in Main() in the same or different class
2. and assigned value from OUTSIDE the method USING INSTANCE in Main() in the same, or different class in which case it should be public
3. and assigned value from OUTSIDE the method USING METHOD CALL in Main() in the same or different class
4. and assigned value INSIDE THE METHOD DIRECT

*instance variable can be used in instance method [in different class] 
ONLY by USING REFERENCE PASSED IN PARAMETER that allows OBJECT PASSED IN ARGUMENT from Main() and should be PUBLIC
[Note: also in same class as one of the ways]


instance variable can be used in static method* 
ONLY by USING REFERENCE PASSED IN PARAMETER that allows OBJECT PASSED IN ARGUMENT from Main()
1. and assigned value from OUTSIDE the method USING CONSTRUCTOR CALL in Main() in the same or different class
2. and assigned value from OUTSIDE the method USING INSTANCE in Main() in the same, or different class in which case it should be public
3. and assigned value from OUTSIDE the method USING METHOD CALL in Main() in the same or different class
4. and assigned value INSIDE THE METHOD DIRECT

*instance variable can be used in static method [in different class]
ONLY by USING REFERENCE PASSED IN PARAMETER that allows OBJECT PASSED IN ARGUMENT from Main() and should be PUBLIC


[INHERITANCE: CANNOT Call PROTECTED INSTANCE FROM DERIVED via a qualifier of type 'BaseClass']


// *Note:
// In case static variable is used either in instance method or static method, 
// and assigned value from OUTSIDE the method USING CONSTRUCTOR CALL in Main() in the same or different class
// UNLIKE THE CASE OF INSTANCE VARIABLE, the STATIC VARIABLE should be called/used immediately after assigned using CONSTRUCTOR CALL, 
// otherwise if called or used after subsequent assignment using CONSTRUCTOR CALL(S)
// ONLY THE LAST ASSIGNMENT VALUE will be its value 
    
// [ALSO IN CASE OF assignments USING CLASS, the STATIC VARIABLE should be called/used immediately after assigned using CLASS, 
// otherwise if called or used after subsequent assignment using CLASS(ES)
// ONLY THE LAST ASSIGNMENT VALUE will be its value 

// [BUT NOT IN CASE OF assignments USING METHOD CALLS in Main() in the same or different class]


*/




18.
// Even though in the same class, instance member cannot be used directly in Main() but using instance 




19. 
// member names cannot be the same as their enclosing type

// A class [including static and abstract](at namespace level) containing class(es)[including static and abstract]/struct(s) can only be 1. public 2. internal 3. default

// A struct (at namespace level) containing class(es)[including static and abstract]/struct(s) can only be 1. public 2. internal 3. default





20.

// (Class/Struct (outer) in namespace) cannot be declared as private, protected, or protected internal

// member names cannot be the same as their enclosing type

// A namespace member contained in a class [including static and abstract] (at namespace level) can be public, private (default), protected, internal, protected internal
// (accessibility as same as class member) 

// A namespace member contained in a struct (at namespace level) can be public, private (default), internal 
// (accessibility as same as struct member) 




21.
// member names cannot be the same as their enclosing type

// A namespace member contained in a class [including static and abstract] (at namespace level) 
// is accessed using the class [including static and abstract] (at namespace level) that contains it 

// A namespace member contained in a struct (at namespace level) is accessed using the struct(at namespace level) that contains it 




22.
// A static constructor (which must be parameterless) can be in class/struct
// A static constructor has no access modifier 
// A static constructor must be parameterless therefore cannot be overloaded
// A static constructor initializes static variables (attributes of a class rather than an instance)
// A static constructor is called automatically before instance constructor
// A static constructor is executed before instance constructor
// A static constructor can also access instance variable (BUT NOT readonly) using: static MyClass mc = new MyClass(); 




23.
/* 

A base class cannot be less accessible than the derived class:

class A {}
public class B : A { } // Not possible because base class is less accessible than the derived class

internal class A {}
internal class B { public class C : A {} } // Possible as long as B is as accessible as A

*/




24. 
/*

If a method's return type is a class, then return type (class) cannot be less accessible than the method 

class A {}
class B 
{  A H() // public not possible, because return type (class) cannot be less accessible than the method 
   {
      
   }
}

*/




25.
/* 

A class/struct can be MORE or LESS accessible than the interface implemented by it:

interface I {}
public class C : I {}

or

public interface I {}
class C : I {}

*/



26.
/*

// accessors' access modifier must be more restrictive than the [property or indexer] 


public string PetName
{
    get { return carName.ToUpperInvariant(); }
    internal  set { carName = value; }
}

// The default access modifier for accessors is the  access modifier of the [property or indexer] and NOT private


// Cannot specify accessibility modifiers for both accessors of the [property or indexer] 
[can only specify either for get or for set accessor]


//Read-Only Standard property
public string PetName
{
    get { return carName.ToUpperInvariant(); }
    private set { carName = value; }
}

//Write-Only Standard property
public string PetName
{
    private get { return carName.ToUpperInvariant(); }
    set { carName = value; }
}

*/




27.
// volatile (nullable type CANNOT be volatile):

// The volatile keyword indicates that a field might be modified by multiple concurrently executing threads
// Fields that are declared volatile are not subject to compiler optimizations that assume access by a single thread
// This ensures that the most up-to-date value is present in the field at all times

// volatile modifier is usually used for a field (static/instance) (BUT NOT const/readonly) that is accessed by multiple threads 
// without using the lock statement to serialize access.

// The volatile keyword can be applied to these types:

// 1. Reference types viz., array, string etc

// 2. Pointer types (in an unsafe context)

// 3. Built-in structs such as sbyte, byte, short, ushort, int, uint, char, float, and bool [cannot be long, ulong, double, decimal]

// 4. An enum type with an integral base type

// 5. Generic type parameters known to be reference types

// 6. IntPtr and UIntPtr

// 7. The type in question must be the field of a class or struct. Local variables cannot be declared volatile


// readonly (nullable type can be readonly):
// 1. can be static or instance 
// 2. static readonly can be Initialized ONLY in declaration OR in its class'[BUT NOT derived] static constructor(which cannot be overloaded)
// 3. instance readonly can be Initialized ONLY in declaration OR in its class'[BUT NOT derived] instance constructor(including overloading) 
// 4. static readonly is accessed with its class, like static member (in instance/static method) 
// 5. instance readonly is accessed with instance reference, like instance member (in instance/static method) 
// 6. Assignment not a MUST, but warning will occur if not assigned
// 7. Local variables cannot be declared readonly


// const (nullable type CANNOT be const): 
// 1. Assigned ONLY AND 2. MUST in declaration 
// 3. Accessed with class like static member (in instance/static method)
// 4. const can be LOCAL (without access specifiers and member modifiers) [inside static/instance method] (ASSIGNMENT AT DECLARATION MUST)
// 5.  A const field of a reference type other than string can only be initialized with null viz., const MyClass _myClass = null;

// Variable AND const can be LOCAL (without access specifiers and member modifiers) [inside static/instance method] (ASSIGNMENT AT DECLARATION MUST)




28.
 
/* 

A statement such as: array[i]; is not possible; But x = array[i]; is possible in a for loop with i iterations with x and array being same types and array[i] already assigned values
int x; // 
int i;
int[] array = new int[10];

for(i=0; i < 10; i++)
    array[i] += i; // Check for array[i] = i;

for(i=0; i < 10; i++)
{
    x = array[i];
    Console.WriteLine("x = " + x);
}
// Console.WriteLine("x = " + x); // x should be assigned such as int x = 0;

*/

// Also: number[i] = i;  is possible in a for loop with i iterations 
// Also: temp += a[i]; temp being string (character array), a[i] being character array ('a' being string)   
// Also: temp += parts[i]; temp and parts being string arrays 




29. 
// || and && Short-Circuit Logical Operators evaluate the second operand only when necessary, otherwise as same as normal versions : | and &




30. 
// Console.Write() is INVALID
// Console.Write("print string") Returns cursor on the same line
// Console.Write(" ") Returns cursor on the same line with one space (" " can be appended with string and can be more than once)
// Console.Write("\n") Returns cursor on the next line ("\n" can be appended with string and can be more than once)

// Console.WriteLine() Returns cursor on the next line
// Console.WriteLine("\n") Returns cursor on the line next to the next line ("\n" can be appended with string and can be more than once)

/* 

Note: 
If Console.WriteLine()  or Console.Write("print string")  is preceded by Console.Write(" ")
Console.WriteLine()  or Console.Write("print string") cursor starts from where Console.Write(" ") returns the cursor that is on the previous line
As a result in this case, Console.WriteLine(); will not create a line of space
so only Console.WriteLine("\n") Console.Write("\n\n") create a line of space

*/




31. 
// "", null, string.Empty, String.Empty for string
// ' ' means one space and only for char
// '' is INVALID




32.
/*

{event} in [struct]:

add:
1. assign the event handler method without parenthesis (using class for static and using object for instance) to the delegate instance
2. add the assigned delegate instance to the event list

remove:
1. remove the assigned delegate instance 

*/  




33.
/*

A private and explicit [interface] implementation of an {event} (by class/struct) must use property syntax

For a private and explicit [interface] implementation of an {event} (by struct) must use property syntax:

use: delegate array

or

use: OnEvent() in [interface]

*/




34.
// {}; for anonymous method, do while, while (not mandatory), array assignment




35. 
/*

While using access modifiers with (property / indexer) accessors:
accessors' access modifier must be more restrictive (less accessible) than the property or the indexer

*/




36.
/*

[interface] {property or indexer} must have at least one accessor 
[interface] {property or indexer} must have either get/set whichever is public

*/




37.
/*

class to struct:
1. cannot have instance field initializers
2. cannot contain EXPLICIT parameterless instance constructors but can have EXPLICIT parameterless static constructors
3. must be fully assigned before control leaves the constructor OR use this()
4. {event} in [struct]:
add:
1. assign the event handler method without parenthesis (using class for static and using object for instance) to the delegate instance
2. add the assigned delegate instance to the event list
remove:
1. remove the assigned delegate instance

*/




38.
// enum // named constants can only be alphanumeric (should start with alphabet), should be unique and should not be in quotation




39. 
// 'this' is the argument for the corresponding object reference parameter

// method without parenthesis is the argument for the corresponding delegate reference parameter




40.
// Inside Console.WriteLine()/Console.Write(), you can call only the method that returns (even if the method contains Console.WriteLine())
// AND the returning method (even if the method contains Console.WriteLine()) can be copied to a variable of type same as the return type of the method, and the variable can be printed
// i.e., a void method cannot be called inside Console.WriteLine()/Console.Write()

// NOTE: 'return;' in a void method means exit and doesn't mean returning value

// NOTE: char method can return (char)0;




41.
/*

In a method:
return x/2; ( x is unassigned)
is different from:
x = x/2; ( x is assigned)
return x;

*/




42. 
/*

An assembly (exe/dll) can be generated using several .cs files (but entry point[static void Main()] in only one of the files):

//>csc 1.cs 1a.cs 1b.cs

//>1

// (1.cs containing entry point[static void Main()])

*/




43. 
/*

Different Assembly:

//>csc 1.cs
//>csc 1a.cs /reference:1.exe


//OR


//>csc /target:library 1.cs
//>csc 1a.cs /reference:1.dll 


//OR


//>csc 1.cs
//>csc 1a.cs /r:1.exe


//OR


//>csc /t:library 1.cs
//>csc 1a.cs /r:1.dll 




Friend Assembly:
using System.Runtime.CompilerServices; // in 1a.cs
[assembly:InternalsVisibleTo("1")]     // declaring 1.cs as friend assembly in 1a.cs // declare for one class, all classes will be shared


//>csc /t:library 1a.cs

//>csc 1.cs /r:1a.dll


//OR


//>csc 1a.cs

//>csc 1.cs /r:1a.exe

*/




44.
/*

From console:
To create exe:
csc 1.cs

To create dll:
csc /t:library 1.cs

(exe/dll will be created in the same folder that you are creating from)

*/




45.
/*

In case of IDE:
1. exe (executable) is created (automatically when you compile) in bin/Debug folder(default) of the application folder 

2. dll (class library) can be created by Selecting File->New->Project->Visual C# Projects->Class Library. 
type the code in Class1.css
build the dll is created (automatically when you BUILD) in bin/Debug folder(default) of the application folder 

*/




46.
/*

For REFLECTION:
1. Copy dll/exe:
bin/Debug folder(default) of the REFLECTION application folder 

OR

2. Add Reference (for the REFLECTION application) by browsing to the folder where the dll/exe is present

*/





47.
/*

// Visual C# 2005 Compiler Options:
// >csc /?


// Compiling unsafe:

// >csc 1.cs /unsafe

// >1


// Visual Studio:

// Open the project's Properties page. For details, see How to: Set Project Properties (C#, J#).

// Click the Build property page.

// Select the Allow Unsafe Code check box.

*/




48.
// The extern modifier is used to declare a method that is implemented externally. 
// A common use of the extern modifier is with the DllImport attribute when using System.Runtime.InteropServices to call into unmanaged code;

// It is an error to use the abstract and extern modifiers together to modify the same member. 
// Using the extern modifier means that the method is implemented outside the C# code, 
// while using the abstract modifier means that the method implementation is not provided in the class.


// The extern keyword also can define an external assembly alias, 
// making it possible to reference different versions of the same component from within a single assembly. 

// It can sometimes be necessary to reference two versions of assemblies that have the same fully-qualified type names, 
// for example when you need to use two or more versions of an assembly in the same application. 
// By using an external assembly alias, the namespaces from each assembly can be wrapped inside root-level namespaces named by the alias,
// allowing them to be used in the same file.

// To reference two assemblies with the same fully-qualified type names, an alias must be specified on the command line, as follows:

// /r:GridV1=grid.dll

// /r:GridV2=grid20.dll

// This creates the external aliases GridV1 and GridV2. To use these aliases from within a program, 

// reference them using the extern keyword. For example:

// extern alias GridV1;

// extern alias GridV2;

 
// Each extern alias declaration introduces an additional root-level namespace that parallels (but does not lie within) the global namespace. 
// Thus types from each assembly can be referred to without ambiguity using their fully qualified name, rooted in the appropriate namespace-alias


// extern alias X; in 1.cs


// csc /t:library 1a.cs

// >csc 1.cs 1b.cs /r:X=1a.dll

// OR

//>csc 1a.cs

//>csc 1.cs 1b.cs /r:X=1a.exe





49.
/*

Generics:

1. indexers, properties, events, operators cannot be generic, 
   but can be used in a generic class and make use of the generic type parameters of that class

2. extern modifier cannot be applied to the generic method

3. pointer types cannot be used as type arguments

4. If a generic class contains a static field, then each constructed type has its own copy of that field. 
   This means that each instance of the same constructed type shares the same static field. 
   However, a different constructed type shares a different copy of that field. 
   Thus a static field is not shared by all constructed types."

5. object can be used as type argument and this can be parameter [but not in static cases]


*/




50.
/*
var (Implicitly-typed local variables):

Implicitly-typed local variables cannot be constant          

The contextual keyword 'var' may only appear within a local variable declaration              

dynamic:

readonly member variable

static readonly member variable

const member variable = null*

local variable

const local variable = null*

A const field of a reference type other than string can only be initialized with null. (Member/Local Variable)    
*/



// CS 12
/*
1. Primary constructors
2. Collection expressions
3. ref readonly parameters
4. Default lambda parameters
5. Alias any type
6. Inline arrays
7. Experimental attribute
8. Interceptors
*/


// CS 11
/*
1. Raw string literals
2. Generic math support
3. Generic attributes
4. UTF-8 string literals
5. Newlines in string interpolation expressions
6. List patterns
7. File-local types
8. Required members
9. Auto-default structs
10. Pattern match Span<char> or ReadOnlySpan<char> on a constant string
11. Extended nameof scope
12. Numeric IntPtr and UIntPtr: nint and nuint types now alias System.IntPtr and System.UIntPtr, respectively
13. ref fields and scoped ref
14. Improved method group conversion to delegate
15. Warning wave 7
*/


// CS 10
/*
1. Record structs
2. Improvements of structure types
3. Interpolated string handlers
4. global using directives
5. File-scoped namespace declaration
6. Extended property patterns
7. Improvements on lambda expressions
8. Allow const interpolated strings
9. Record types can seal ToString()
10. Improved definite assignment
11. Allow both assignment and declaration in the same deconstruction
12. Allow AsyncMethodBuilder attribute on methods
13. CallerArgumentExpression attribute
14. Enhanced #line pragma
15. Warning wave 6
*/


// CS 9
/*
1. Records
2. Init only setters
3. Top-level statements
4. Pattern matching enhancements
5. Native sized integers
6. Function pointers
7. Suppress emitting localsinit flag
8. Target-typed new expressions
9. static anonymous functions
10. Target-typed conditional expressions
11. Covariant return types
12. Extension GetEnumerator support for foreach loops
13. Lambda discard parameters
14. Attributes on local functions
15. Module initializers
16. New features for partial methods
17. Warning wave 5
*/


// CS 8
/*
1. Readonly members
2. Default interface methods
3. Pattern matching enhancements:
// Switch expressions
// Property patterns
// Tuple patterns
// Positional patterns
4. Using declarations
5. Static local functions
6. Disposable ref structs
7. Nullable reference types
8. Asynchronous streams
9. Indices and ranges
10. Null-coalescing assignment
11. Unmanaged constructed types
12. Stackalloc in nested expressions
13. Enhancement of interpolated verbatim strings
14. Interface with member access specifiers and static members including fields
15. ! (null-forgiving) operator
*/


// CS 7.3
/*
// New features
9. Access fixed fields without pinning.
10. Reassign ref local variables.
11. Initializers on stackalloc arrays.
12. Fixed statements with any type that supports a pattern.
13. Additional generic constraints. // Unmanaged constraint // Delegate constraints // Enum constraints
// Enhancements
14. Test == and != with tuple types.
15. Expression variables in more locations.
16. Attach attributes to the backing field of auto-implemented properties.
17. Method resolution when arguments differ by in has been improved.
18. Overload resolution now has fewer ambiguous cases.
// New compiler options
19. -publicsign and -pathmap
// -publicsign to enable Open Source Software (OSS) signing of assemblies.
// The -publicsign compiler option instructs the compiler to sign the assembly using a public key. 
// The assembly is marked as signed, but the signature is taken from the public key. 
// This option enables you to build signed assemblies from open-source projects using a public key.
// -pathmap to provide a mapping for source directories.
// The -pathmap compiler option instructs the compiler to replace source paths from the build environment with mapped source paths. 
// The -pathmap option controls the source path written by the compiler to PDB files or for the CallerFilePathAttribute.
*/

// CS 7.2
/*
5. Techniques for writing safe efficient code
// A combination of syntax improvements that enable working with value types using reference semantics.
6. Non-trailing named arguments
// Named arguments can be followed by positional arguments.
7. Leading underscores in numeric literals
// Numeric literals can now have leading underscores before any printed digits.
8. private protected access modifier
// The private protected access modifier enables access for derived classes in the same assembly. // Not in different assembly.
*/

// CS 7.1
/*
1. async Main method
// The entry point for an application can have the async modifier.
2. default literal expressions
// You can use default literal expressions in default value expressions when the target type can be inferred.
3. Inferred tuple element names
// The names of tuple elements can be inferred from tuple initialization in many cases.
// Finally, the compiler has two options /refout and /refonly that control reference assembly generation.
4. Reference assembly generation
// There are two new compiler options that generate reference-only assemblies: /refout and /refonly. 
// /refout a
// The -refout option specifies a file path where the reference assembly should be output.
// This translates to metadataPeStream in the Emit API.
// /refonly
// The -refonly option indicates that a reference assembly should be output instead of an implementation assembly, as the primary output.
// The -refonly parameter silently disables outputting PDBs, as reference assemblies cannot be executed.
*/

// CS 7
/*
1. out variables
2. Tuples
3. Discards
4. Pattern Matching
5. ref locals and returns
6. Local Functions
7. Expression-bodied members
8. Throw expressions
9. Generalized async return types
10. Numeric literal syntax improvements
*/


// CS 6
/*
1. Read-only Auto-properties
2. Auto-Property Initializers
3. Expression-bodied function members
4. using static
5. Null-conditional operators
6. String Interpolation
7. Exception filters
8. nameof Expressions
9. await in catch and finally blocks
10. Index initializers
11. Extension methods for collection initializers
12. Improved overload resolution
13. Deterministic compiler output
*/


// CS 5
/*
async
await
*/


// CS 4
/*
1. Dynamic Binding
2. Optional Parameters
3. Named Arguments
4. Variance - Covariance and Contravariance
5. Tuple
*/


// CS 3
/*
1. Implicitly Typed Local Variables
2. Implicitly Typed Arrays
3. Query Expressions (LINQ)
4. Anonymous Types
5. Object and Collection Initializers
6. Extension Methods
7. Lambda Expressions
8. Expression Trees
9. Automatically Implemented Properties
10. Partial Classes and Methods (Partial Classes, Structs, and Interfaces were available in CS 2)
*/

// Note
// LINQ is supported by a set of interrelated features including the query syntax, Lambda Expressions, Anonymous Types, and Extension Methods
// Anonymous Type directly relates to LINQ
// Anonymous type is a class that has no name
// The primary use of Anonymous Type is to create an object returned by the select clause
// The primary use of the object 


// CS 2
/*
1. Generics
2. Nullable types
3. Iterators
4. yield Statement
5. Partial Classes/Structs/Interfaces
6. Anonymous methods
7. The :: operator (Namespace Alias Qualifier)
8. Static Classes
9. Covariance and contravariance
10. Fixed-size buffers
Note: fixed keyword [only with built-in struct except decimal, only in unsafe, cannot be static]
11. Friend assemblies
12. Extern Aliases [extern keyword has been available since C# 1.0]
13. Delegate Method Group Conversion
14. Access Modifiers with Accessors [Note: For properties and indexers]
15. #pragma directives
16. ?? Operator or Null-Coalesce Operator
17. System.Predicate
18. System.Action
*/


// CS 1.x
/*
Unified Type System - Data Types
|
|`-Value Types
| |
| |`--Built-in Value Types
| | |
| |  `---Built-in Structs
| |   |
| |   |`----Numeric Types
| |   | |
| |   |  `-----Integral Types
| |   |   |
| |   |   |`------sbyte
| |   |   |
| |   |   |`------byte
| |   |   |
| |   |   |`------short
| |   |   |
| |   |   |`------ushort
| |   |   |
| |   |   |`------int
| |   |   |
| |   |   |`------uint
| |   |   |
| |   |   |`------long
| |   |   |
| |   |   |`------ulong
| |   |   |
| |   |   |`------char
| |   |   |
| |   |   |`-----Floating-point Types
| |   |   |  |
| |   |   |  |`------float
| |   |   |  |
| |   |   |   `------double
| |   |   |
| |   |    `-----decimal
| |   |
| |    `----bool
| |
|  `--User-defined Value Types
|   |
|   |`---User-defined Structs [Auto-default Structs (>= CS 11)]
|   |    |
|   |     `---readonly struct (>= CS 7.2)
|   |    |
|   |     `---ref struct (>= CS 7.2)
|   |    |
|   |     `---readonly ref struct (>= CS 7.2)
|   |    |
|   |     `---record struct (>= CS 10)
|   |    |
|   |     `---readonly record struct (>= CS 10)
|   |
|    `---Enums
|     
|`-Reference Types
| |
| |`--User-defined Reference Types
| | |
| | |`---class
| | |
| | |`---interface
| | |
| | |`---delegate
| | |
| |  `---Array
| | |
| |  `---record (>= CS 9)
| |   |
| |    `---positional record (>= CS 9)
| |
|  `--Built-in Reference Types
|   |
|   |`---object
|   |
|   |`---string
|   |
|    `---dynamic (>= CS 4)
|
 `-Pointer Types (Unsafe)


Type Members
|
|`-data members (variables and consts can be local)
| |
| |`--consts
| |
| |`--static fields (including static volatile and static readonly) 
| |
|  `--instance fields (including instance volatile and instance readonly)
|
 `-function members
  |
  |`--methods (instance/static)
  |
  |`--construcutors (instance/static(which must be parameterless))
  |
  |`--destructors (called prior to garbage collection before program terminates [not called when object goes out of scope and differs from C++ destructors that are called when object goes out of scope]) 
  |
  |`--indexers (instance, cannot return void)
  |
  |`--properties (instance/static, cannot return void)
  |
  |`--events (instance/static)
  |
   `--operators (static)
*/

/******************************************************************************/